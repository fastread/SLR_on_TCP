ID,Document Title,Abstract,Year,PDF Link,code,
1,Application of Decision Theory to the Testing of Large Systems,"A methodology for determining priorities in allocating test resources among the various subsystems within a large system is described. The methodology is based on concepts from applied decision theory. Two versions of the methodology are presented: a complete version, called the extensive form, and an approximate version, called the diminutive form.",1971,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4103708,yes,
2,Multiaccess in a Nonqueueing Mailbox Environment,"A new and flexible solution to the problem of multiple users accessing a single resource, such as communication bandwidth or composite object in memory, is derived. The means of communication consists of sending and receiving messages in known locations (or equivalently, mailboxes without queueing). Any particular user is able to deposit, and hence destroy, previous messages in a mailbox. It is assumed that exclusive access to a mailbox is supplied by an underlying system. The major results of this paper are: 1) a simple tree-based algorithm that guarantees ƒ?› no user or group of users can conspire to prevent access by some other user to the resource; ƒ?› only one user accesses the resource at a time; ƒ?› if there are N users, an individual user is guaranteed access, when requested, to the resource in no more than N-1 turns; Knuth's solution [6] can delay a user up to 2** (N-1)-1 turns; 2) an extension of Dekker's algorithm (2 users) [2] that allows the relative rates of reservations for access to the resource to be proportional to a set of N integers. When a reservation is not being used by its ``owner,'' it will be assigned to another contending request. The assignment is optimal for periodic requests.",1984,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5010232,no,
3,Practical Priorities in System Testing,"During the system test phase, ""thorough testing"" can pass the limits of practicality. Test case selection, based on simple priority rules, is one solution to the problem of practicality vs. thoroughness.",1985,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1695401,yes,
4,Testing and Evaluation of the Defense Data Network,"The purpose of this document is to establish a concept for test and evaluation (T&E) for the Defense Data Network (DDN) as a whole. This concept is based on the requirements of the DDN in its evolving configurations (e.g., MILNET, SACDIN, DODIIS, ..., DDN); the goals and priorities of the DDN DCS DSD; the needs of the various DDN user communities; knowledge of the ARPANET technology; and experience in T&E of systems and independent verification, validation, and test (IVV&T) of software and hardware. Since 1983 Intermetrics has been a contractor for Independent Validation and Verification (IV&V) support to the Testing branch of the Defense Data Network Defense Communications System Data Systems Directorate (DDN DCS DSD).",1987,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4795240,no,
5,Formal methods and iterative design,"Formal methods allow a system designer to describe precisely how the system will be. In the area of human-computer interaction this means describing the structure and detail of the user interface. Giving the designer tools to think clearly about the decisions made must be helpful. However, the problem of deciding how the user interface is to be designed remains. In particular, to use such tools effectively a designer must have a good understanding of how the users think about the task, what their expectations and priorities are. This kind of information is best obtained by user testing with prototypes. An initial design is put forward and then refined using feedback from typical users doing typical tasks with a prototype. This refinement should happen in parallel with the refinement of a formal model of the user interface by the application of domain independent principles. In the early stages the cost of this procedure can be minimised by using simulations and mock ups rather than full prototypes. This is known as iterative design. This paper describes, through an example, some techniques which can be used to get insights about how a user approaches a task and the difficulties they have with a particular prototype.<<ETX>>",1988,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=209309,no,
6,Real-time adaptive control of knowledge based avionics tasks,"Advanced decision-making capabilities are being developed to aid the pilots of the next generation of tactical fighters. Due to the limited processing resources available in an avionics suite, efforts have focused on developing a distributed fault-tolerant software architecture that permits the real-time prioritization and scheduling of these tasks. The authors outline the design details of an architecture under development to meet these performance requirements. The system has been tested with a threat-avoidance system, implemented on a testbed of five internetted LISP workstations, to evaluate overall system capabilities including scheduling, task operations, and database accesses. It has a simulation cycle of 50 ms and synchronization between distributed nodes can be achieved within 2 ms. This test case has nine knowledge tasks, one of which is defined as a simulation cycle that drives the test case. This system has been evaluated with the current trace capabilities and runs with a peak of 16 task instances active at any time.<<ETX>>",1989,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=40357,no,
7,Group decision support and multiple criteria optimization,The paper proposes a structured group decision aid based on multiple criteria optimization. The procedure is designed to solve optimization problems which involve conflicting objectives and multiple decision-makers with different priorities. Most of the empirical findings regarding the performance of multi criteria techniques involve a single decision-maker. The focus in these algorithms is on determining a compromise solution to a multicriteria problem which best coincides with the preference structure of a decision-maker. The approach taken is to imbed the task of finding a compromise solution in a more general and flexible framework. The underlying concept in this framework is the analytic hierarchy process and the Tchebycheff algorithm is used to solve the multiple criteria problem. The objectives and the alternative solutions to the multiple criteria problem are evaluated through the analytic hierarchy process.<<ETX>>,1991,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=184201,no,
8,Setting maintenance quality objectives and prioritizing maintenance work by using quality metrics,"Metrics that are collected and validated during development can be used during maintenance to control quality and prioritize maintenance work. Validity criteria are defined mathematically. The approach is based on validating selected metrics against related quality factors during development and using the validated metrics during maintenance to: establish initial quality objectives and quality control criteria and prioritize software components (e.g., module) and allocate resources to maintain them. The author illustrates both a case of passing a validation test (discriminative power) and failing a validation test (tracking).<<ETX>>",1991,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=160337,no,
9,Specification criticism via goal-directed envisionment,"Validating a complex system specification is a difficult problem. Generating behaviors and using them to critique a specification is one effective approach. Up until now, symbolic evaluation has been the key technique of behavior generation. Unfortunately, it has drawbacks both in the amount of time it takes to complete a symbolic run, and in the large amount of uninteresting data it produces. The authors propose goal-directed envisionment as an alternative to symbolic evaluation, supplementing the basic envisioning techniques of qualitative physics with behavioral goals. This approach overcomes the problems of symbolic evaluation by generating interpretations in a reasonable amount of time and by exploiting goals to prioritize and analyze the interpretations. The authors describe and evaluate SC, an implemented system which employs goal-directed envisionment to critique specifications.<<ETX>>",1991,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=213080,no,
10,Quality Function Deployment (QFD) in testing,"QFD is a quality-oriented process that can play an important role in the market-driven, total quality control environment. It can be deployed in almost all areas of product development, test and manufacturing processes. QFD is one way to ensure the reliability of the software products. The author is concerned with the role that software testing can play in increasing the reliability of software. He also examines how Quality Function Deployment (QFD) could be used to achieve this objective. QFD provides integration of the various functions by tying design and process activities together. It priorities product and manufacturing-process characteristics and highlights areas which would require further analysis.<<ETX>>",1992,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=168144,no,
11,A method for automatic evaluation of fault effects in the advanced intelligent network,"The method described here provides network operators with criteria for deciding the priorities with which services degraded by network faults should be restored. This method consists of four processes: the first lists the unavailable services of customers affected by the fault, the second predicts the mean time needed to repair the fault, the third predicts the traffic trends for the affected services, and the fourth calculates the criteria used to decide the service restoration priorities. This method enables network operators to choose suitable means restoring services and to avoid future congestion due to faults. It also lets them respond more quickly and precisely to customer claims. We are introducing this method into our advanced IN operations systems.<<ETX>>",1993,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=318129,no,
12,New probabilistic measures for accelerating the automatic test pattern generation algorithm,"In order to approximate the signal controllabilities, the authors introduce new probabilistic measures called signal priorities, whose computation relies on the minimum-value distributions of fanout input variables of a digital circuit. The signal priorities serve the same purpose as do the signal controllabilities. That is, they are used to accelerate the automatic test pattern generation algorithm; however, their computation requires much less effort. This new method is formally defined and tested with several practical example circuits.<<ETX>>",1993,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=396314,no,
13,Cost-benefit analysis of electric power system reliability,"The purpose of this investigation is to determine an appropriate cost-benefit formula that will help the power system planners in prioritizing transmission system projects. This paper deals with describing the value of increased reliability and security in bulk power systems. Three different approaches used for prioritization of transmission system projects by the electric utilities are discussed and analyzed for two different transmission system alternatives. Utilizing the best approach, transmission alternatives are prioritized and the best alternative is placed on top of the prioritized table. An analysis of the three approaches and a relative comparison is performed on the IEEE 25 bus Reliability Test System. TRELSS (Transmission Reliability Evaluation of Large Scale Systems), a software package developed by EPRI, is utilized in determining the probabilistic indices that are used in the proposed approach.<<ETX>>",1994,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=287831,no,
14,Priority based data flow testing,"Software testing is an expensive component of software development and maintenance. For data flow testing, test cases must be found to test the def-use pairs in a program. Since some of the def-use pairs identified through static analysis may be infeasible, no amount of testing effort may result in exhaustive testing of a program. Therefore in practice a fixed amount of effort is spent in testing a program. We develop an approach for assigning priorities to def-use pairs, such that the def-use pairs with higher priorities can be expected to require less effort for test case generation and therefore testing. Thus, by using the priorities as a guide for ordering the def-use pairs for testing, we can maximize the number of def-use pairs tested using a fixed amount of testing effort. We apply the technique to regression testing during the software maintenance phase, in which case the priorities are assigned to capture not only the difficulty in test case generation but also the likelihood that an error introduced by a program change is uncovered by the test case.",1995,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=526556,yes,
15,The peer tasking design method,"This paper is a preliminary report of an ARPA sponsored study. It focuses on designing real-time command and control or battle management systems for parallel and distributed architectures. Due to delays in other ARPA programs, the targeted architectures were not available during the time frame of the study. The results of the study were, however, tested on more conventional sequential and parallel platforms. The design method discussed here is fundamentally different from those assumed by current real-time scheduling theories, e.g., rate-monotonic, earliest-deadline-first, least-laxity or best-effort. These theories assume that the fundamental unit of prioritization is the task. In this new method, the fundamental unit of prioritization is called a work item. Work items are functions the system performs that have timing requirements (deadlines) associated with them in the requirements specification. Current scheduling theories are applied using artifact deadlines introduced by designers whereas this new method schedules work items to meet specification deadlines (sometimes called end-to-end deadlines) required by the user. With this method, tasks have no priorities. A collection of tasks with no priorities will be called a collection of peer tasks. The study showed that it is possible to schedule work items based on importance rather than urgency while still meeting as many work item deadlines as can be met by scheduling tasks with respect to urgency. Also, it showed that the minimum on-line deadline that can be guaranteed for a work item of highest importance, scheduled at run-time, is approximately the inverse of the throughput, measured in work items per second, for a work load consisting only of work items of that type. Further, it was shown that it provides optimal utilization of a single processor machine, and that its timing behavior is predictable (provable) for both single and multiprocessor machines. Finally, it was shown that throughput is not degraded during overload.<<ETX>>",1995,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=470511,no,
16,High-level synthesis of recoverable microarchitectures,Two algorithms that combine the operations of scheduling and recovery point insertion for high-level synthesis of recoverable microarchitectures are presented. The first uses a prioritized cost function in which functional unit cost is minimized first and register cost second. The second algorithm minimizes a weighted sum of functional unit and register costs. Both algorithms are optimal according to their respective cost functions and require less than 10 minutes of CPU time on widely-used high-level synthesis benchmarks. The best previous result reported several hours of CPU time for some of the same benchmarks.,1996,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=494128,no,
17,Selecting engineering techniques using fuzzy logic based decision support,"The task of selecting software engineering methods, techniques, metrics, and tools is usually performed manually, based on the expertise of individuals. This paper presents a systematic tool supported approach, that bases its suggestions an the technical situation, the existing goals, and constraints of a specific organization or a particular project. A prototype of the decision support system supports the elaboration of test strategies. The approach uses information about the technical situation that is provided by answering predefined questions with fuzzy data. The objective is to assign ""adequacy values"" to combinations of test methods, techniques, metrics, tools, and quantified test situations. The priorities of goals and constraints have assessed by applying a technique that is based on comparing goals in pairs. This permits to check certain consistency criteria by static analysis. A hierarchy of the importance of goals and constraints is calculated, which provides the basis for the determination of the suitability of test methods; techniques, metrics, and tools with respect to goals and constraints.",1996,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=494570,no,
18,A high-level synthesis approach to design of fault-tolerant systems,"Fault-tolerance in embedded systems is a requirement of increasing importance; solutions must achieve a balance between performances and costs that was not usually requested in design of more classical fault-tolerant applications and that involves as a consequence new approaches. A design technique is here proposed supporting fault-tolerance of hardware modules in complex hardware-software systems, fault-tolerance requirements for each hardware-mapped process are specified in terms of time constraints and of relative priorities, and a high-level synthesis methodology allowing to design - for each process - a processor capable of supporting both the nominal execution of the process itself in a fault-free environment and simultaneous execution of a reconfigured pair of processes in a fault-affected environment is defined Performances of the scheduling algorithm, allowing to achieve reconfiguration with minimum resource increase and within the required limits of speed degradation, are evaluated on some relevant instances of algorithms discussed in current literature on high-level synthesis.",1997,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=600305,no,
19,A multi-platform support environment,"Legacy weapon systems, such as attack aircraft, have taken advantage of embedded computers and software to provide enormous capabilities for flexibility and expandability. The provision of these capabilities has been at a cost, and that is in the dedicated software development facilities which have sprung up to support these legacy systems. Unfortunately, the costs of these dedicated facilities is becoming prohibitive. The Advanced Avionics Multi-Radar Software Support Study (AAMRSSS) project offers experience in handling the above problem. AAMRSSS studied the feasibility of using a dedicated Software Development Facility (SDF) to support multiple software system platforms. Issues of the study were: commonality; unique requirements of the new system to be added; platform priorities; and future expansion. In particular, this study has addressed supporting the AC-130U Gunship's Radar Operational Flight Program (OFF) in the F-15's Radar Software Development Facility.",1997,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=622734,no,
20,A study of effective regression testing in practice,"The purpose of regression testing is to ensure that changes made to software, such as adding new features or modifying existing features, have not adversely affected features of the software that should not change. Regression testing is usually performed by running some, or all, of the test cases created to test modifications in previous versions of the software. Many techniques have been reported on how to select regression tests so that the number of test cases does not grow too large as the software evolves. Our proposed hybrid technique combines modification, minimization and prioritization-based selection using a list of source code changes and the execution traces from test cases run on previous versions. This technique seeks to identify a representative subset of all test cases that may result in different output behavior on the new software version. We report our experience with a tool called ATAC (Automatic Testing Analysis tool in C) which implements this technique.",1997,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=630875,yes,
21,A systematic tradeoff analysis for conflicting imprecise requirements,"The need to deal with conflicting system requirements has become increasingly important over the past several years. Often, these requirements are elastic in that they can be satisfied to a degree. The overall goal of this research is to develop a formal framework that facilitates the identification and the tradeoff analysis of conflicting requirements by explicitly capturing their elasticity. Based on a fuzzy set theoretic foundation for representing imprecise requirements, we describe a systematic approach for analyzing the tradeoffs between conflicting requirements using the techniques in decision science. The systematic tradeoff analyses are used for three important tasks in the requirement engineering process: (1) for validating the structure used in aggregating prioritized requirements, (2) for identifying the structures and the parameters of the underlying representation of imprecise requirements and (3) for assessing the priorities of conflicting requirements. We illustrate these techniques using the requirements of a conference room scheduling system.",1997,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=566845,no,
22,An optimal algorithm for scheduling soft aperiodic tasks in dynamic-priority preemptive systems,"The paper addresses the problem of jointly scheduling tasks with both hard and soft real time constraints. We present a new analysis applicable to systems scheduled using a priority preemptive dispatcher, with priorities assigned dynamically according to the EDF policy. Further, we present a new efficient online algorithm (the acceptor algorithm) for servicing aperiodic work load. The acceptor transforms a soft aperiodic task into a hard one by assigning a deadline. Once transformed, aperiodic tasks are handled in exactly the same way as periodic tasks with hard deadlines. The proposed algorithm is shown to be optimal in terms of providing the shortest aperiodic response time among fixed and dynamic priority schedulers. It always guarantees the proper execution of periodic hard tasks. The approach is composed of two parts: an offline analysis and a run time scheduler. The offline algorithm runs in pseudopolynomial time O(mn), where n is the number of hard periodic tasks and m is the hyperperiod/min deadline.",1997,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=601081,no,
23,Design and implementation of a real-time switch for segmented Ethernets,"Providing network bandwidth guarantees over an Ethernet requires coordination of the network nodes for traffic prioritization such that real-time data can have deterministic access to the network. We have shown previously how RETHER, a software based token passing protocol can efficiently provide real-time support over a single shared Ethernet segment. This work extends the token passing mechanism into a switched, multi-segment Ethernet environment. This paper describes the detailed design issues, their solutions, and a fully operational switch implementation built into the FreeBSD kernel. By testing the protocol independently and as the underlying network protocol of the Stony Brook Video Server, we have verified that the bandwidth guarantees are successfully provided, with relatively low run-time overhead, for real-time connections crossing multiple Ethernet segments. This paper also provides a comprehensive performance evaluation of the prototype.",1997,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=643709,no,
24,Failproof team projects in software engineering courses,"The computer science department of the University of Pittsburgh offers two undergraduate and two graduate courses in software engineering in which we emphasize the importance of general engineering principles for software development. For the last ten years the undergraduate courses have been based on team projects. This structure has advantages: students see immediately the relevance of what they learn, and the team setting leads to a better understanding of what they learn. The projects in the two courses are of different types. In one course the result is the formal specification and design of a software system. In the other, the teams implement such a system, but emphasis is on testing rather than on the implementation itself. The success of each project is guaranteed by making it open-ended. A team establishes a list of priorities that is to ensure that a useful product will have been built by the time the term ends. We discuss the nature of team projects, and our evaluation scheme.",1997,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=636027,no,
25,Prioritizing Software Requirements In An Industrial Setting,,1997,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=610408,no,？
26,READS: a prototyping environment for real-time active applications,"We present our Real-time Active Database System, READS, which is a prototyping environment for real-time active database applications on a conventional Unix environment, e.g., Solaris 2.4. In READS, transactions are associated with deadlines and priorities. Priority scheduling is supported by the real-time extensions provided in the underlying operating system. READS can be served as a testbed for evaluating different issues in the design of real-time active database systems (RTADBS). Different approaches for assigning deadlines and priorities to triggered transactions have been suggested and discussed. An application, the programmed trading database system, is implemented with READS and experiments have been performed to study the impact of the deadline constraints on the performance of the deferred and immediate coupling modes for triggering.",1997,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=617285,no,
27,Stochastic Petri nets applied to the performance evaluation of static task allocations in heterogeneous computing environments,"A stochastic Petri net (SPN) is systematically constructed from a task graph whose component subtasks are statically allocated onto the processor suite of a heterogeneous computing system (HCS). Given that subtask execution times are exponentially distributed an exponential distribution can be generated for the overall completion time. In particular the enabling functions and rate functions used to specify the SPN model provide needed versatility to integrate processor heterogeneity, task priorities, allocation schemes, communication costs, and other factors characteristic of a HCS into a comprehensive performance analysis. The manner in which these parameters are incorporated into the SPN allows the model to be transformed into a testbed for optimization schemes and heuristics. The proposed approach can be applied to arbitrary task graphs including non-series-parallel.",1997,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=581420,no,
28,Testing for millennium risk management,"The Year 2000 conversion is a challenge to the economics of both testing and maintenance, but as a whole we are not responding with balanced priorities. Those looking for Year 2000 solutions typically allocate their first energies and budgets to acquiring automated analysis and conversion deals and services. This disturbing tendency ignores two facts that surface in virtually every analysis of the Year 2000 challenge: fifty percent or more of the effort will be in testing; and despite consuming a wealth of resources each year, current testing practices cannot satisfy the demands of current maintenance unrelated to the Y2K conversion. For the moment, most organizations continue to delay action on the Y2K Test problem while wading through the dozens of available analysis and conversion solutions. As a result, many Y2K projects have started on master plans that will need major revision once the true needs and benefits of testing automation become apparent. A growing number of those projects have already corrected course, revising strategy and reallocating budgets once they appreciated the nature of the Y2K testing challenge. Embarrassment will probably be the least of many worries for those that ignore the challenge much longer.",1997,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=589256,no,
29,Derivation of an integrated operational profile and use case model,"Requirements engineering and software reliability engineering both involve model building related to the usage of the intended system; requirements models and test case models respectively are built. Use case modelling for requirements engineering and operational profile testing for software reliability engineering are techniques which are evolving into software engineering practice. Approaches towards integration of the use case model and the operational profile model are proposed. By integrating the derivation of the models, effort may be saved in both development and maintenance of software artifacts. Two integration approaches are presented, transformation and extension. It is concluded that the use case model structure can be transformed into an operational profile model adding the profile information. As a next step, the use case model can be extended to include the information necessary for the operational profile. Through both approaches, modelling and maintenance effort as well as risks for inconsistencies can be reduced. A positive spin-off effect is that quantitative information on usage frequencies is available in the requirements, enabling planning and prioritizing based on that information.",1998,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=730843,no,
30,Prioritized token-based mutual exclusion for distributed systems,"A number of solutions have been proposed for the problem of mutual exclusion in distributed systems. Some of these approaches have since been extended to a prioritized environment suitable for real-time applications but impose a higher message passing overhead than our approach. We present a new protocol for prioritized mutual exclusion in a distributed environment. Our approach uses a token-based model working on a logical tree structure, which is dynamically modified. In addition, we utilize a set of local queues whose union would resemble a single global queue. Furthermore, our algorithm is designed for out-of-order message delivery, handles messages asynchronously and supports multiple requests from one node for multi-threaded nodes. The prioritized algorithm has an average overhead of O(log(n)) messages per request for mutual exclusion with a worst-case overhead of O(n), where n represents the number of nodes in the system. Thus, our prioritized algorithm matches the message complexity of the best non-prioritized algorithms while previous prioritized algorithms have a higher message complexity, to our knowledge. Our concept of local queues can be incorporated into arbitrary token-based protocols with or without priority support to reduce the amount of messages. Performance results indicate that the additional functionality of our algorithm comes at the cost of 30% longer response times within our test environment for distributed execution when compared with an unprioritized algorithm. This result suggests that the algorithm should be used when strict priority ordering is required.",1998,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=670018,no,
31,Software testability measurements derived from data flow analysis,"The purpose of the research is to develop formulations to measure the testability of a program. Testability is a program's property which is introduced with the intention of predicting efforts required for testing the program. A program with a high degree of testability indicates that a selected testing criterion could be achieved with less effort and the existing faults can be revealed more easily during testing. We propose a new program normalization strategy that makes the measurement of testability more precise and reasonable. If the program testability metric derived from data flow analysis could be applied at the beginning of a software testing phase, much more effective testing of resource allocation and prioritizing is possible.",1998,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=665760,yes,
32,Scenario based integration testing for object-oriented software development,"The adaptive use case methodology for software development proposed by Carlson and Hurlbutt [1997, 1998] forms the backdrop for this paper. Their methodology integrates the software design, development and testing processes through a series of design preserving, algorithmic transformations. This paper focuses on the software testing metrics used in the generation of object oriented test plans as part of that methodology. During the design phase, interaction diagrams are developed from which use case action matrices are then generated. A use case action matrix contains a collection of related scenarios each describing a specific variant of an executable sequence of use case actions. The proposed software testing metrics are employed to improve the productivity of the testing process through scenario prioritization.",1999,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=810764,no,
33,"Static properties of commercial embedded real-time programs, and their implication for worst-case execution time analysis","We have used a modified C compiler to analyze a large number of commercial real time and embedded applications written in C for 8- and 18-bit processors. Only static aspects of the programs have been studied i.e., such information that can be obtained from the source code without running the programs. The purpose of the study is to provide guidance for the development of worst-case execution time (WCET) analysis tools, and to increase the knowledge about embedded programs in general. Knowing how real programs are written makes it easier to focus research in relevant areas and set priorities. The conclusion is that real time and embedded programs are not necessarily simple just because they are written for small machines. This indicates that real life WCET analysis tools need to handle advanced programming constructions, including function pointer calls and recursion.",1999,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=777660,no,
34,Static-priority scheduling of multiframe tasks,The multiframe model of hard-real-time tasks is a generalization of the well-known periodic task model of C. Liu and J. Layland (1973). The feasibility analysis of systems of multiframe tasks which are assigned priorities according to the rate-monotonic priority assignment scheme is studied. An efficient sufficient feasibility test for such systems of multiframe tasks is presented and proved correct-this generalizes a result of A.K. Mok and D. Chen (1997).,1999,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=777448,no,
35,Teenagers identify causes of violence in schools and develop strategies to eliminate violence using GroupSystems electronic meeting system (EMS),"Is it possible to engage teenagers in a serious effort to identify the root causes of school violence and to develop strategies to deal with it? If so, will computer-aided group decision support tools add value to the process? Those are the questions we addressed with the 1998 Teen Think Tank on School Violence. While this was neither a formal nor a scientific treatment of the subject, the results of the initial experiment were overwhelmingly impressive. Using the GroupSystems Electronic Meeting System (EMS), sixteen teenagers grappled with the issue of school violence and generated more than 800 different ways to predict, prevent, avoid, protect, react, eliminate, or cope with youth violence. After brainstorming for ideas, they also used EMS to categorize, prioritize, and to reach consensus about their best ideas. Then they developed teen recommendations for students, parents, teachers, school administrators, and law enforcement officers. This was all accomplished in two EMS sessions; and none of the students had any prior knowledge or experience with EMS. This report presents a synopsis of their findings and a brief description of the EMS process.",1999,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=772733,no,
36,Test case prioritization: an empirical study,Test case prioritization techniques schedule test cases for execution in an order that attempts to maximize some objective function. A variety of objective functions are applicable; one such function involves rate of fault detection-a measure of how quickly faults are detected within the testing process. An improved rate of fault detection during regression testing can provide faster feedback on a system under regression test and let debuggers begin their work earlier than might otherwise be possible. In this paper we describe several techniques for prioritizing test cases and report our empirical results measuring the effectiveness of these techniques for improving rate of fault detection. The results provide insights into the tradeoffs among various techniques for test case prioritization.,1999,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=792604,yes,
37,The far ultraviolet spectroscopic explorer (FUSE) instrument data system,"This paper describes the architecture for the IDS flight hardware and its real-time embedded flight software. The design uses commercial off-the-shelf (COTS) software components as much as possible, to reduce cost and software development time. The features of the IDS design that provide radiation hardness and fault tolerance are described. Implementation of software to meet the functional requirements is accomplished using a relatively small number of prioritized real-time tasks. A commercial real-time operating system kernel manages and supports these tasks. Inter-task communication is described, as are the software test and validation methods. The paper shows how custom ground support equipment was developed to facilitate software development and testing. Reliable communications between the IDS and the FUSE spacecraft bus are accomplished using a MIL-STD-1553B bus that has an imposed, deterministic real-time protocol. Similarly, communication between the IDS and the other instrument subsystems uses a second MIL-STD-1553B bus that has its own time division multiplex real-time protocol. The design of these real-time protocols is described, with particular attention to reliability and testability.",1999,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=821995,no,
38,A physics/engineering of failure based analysis and tool for quantifying residual risks in hardware,"NASA Code Q is supporting efforts to improve the verification and validation and the risk management processes for spaceflight projects. A physics-of-failure based Defect Detection and Prevention (DDP) methodology previously developed has been integrated into a software tool and is currently being implemented on various NASA projects and as part of NASA's new model-based spacecraft development environment. The DDP methodology begins with prioritizing the risks (or failure modes, FMs) relevant to a mission which need to be addressed. These risks can be reduced through the implementation of a set of detection and prevention activities referred to herein as PACTs (preventative measures, analyses, process controls and tests). Each of these PACTs has some effectiveness against one or more FMs but also has an associated resource cost. The FMs can be weighted according to their likelihood of occurrence and their mission impact should they occur. The net effectiveness of various combinations of PACTs can then be evaluated against these weighted FMs to obtain the residual risk for each of these FMs and the associated resource costs to achieve these risk levels. The process thus identifies the project-relevant ""tall pole"" FMs and design drivers and allows real time tailoring with the evolution of the design and technology content. The DDP methodology allows risk management in its truest sense: it identifies and assesses risk, provides options and tools for risk decision making and mitigation and allows for real-time tracking of current risk status.",2000,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=816338,no,
39,Architecture of the simplified Chinese embedded system STARTH,"There is a trend for the information products that are integrated by computer, communication, and consumer electronics. The OS is required more compact and practical. An embedded system STARTH is developed based on the core of the Motorola PPSM that is a real time 32-bit kernel with prioritized interrupt scheduling. All tasks are interrupt-driven. The PPSM kernel does not access hardware device directly. The kernel controls all peripherals indirectly, through software device drivers. The PPSM tools consist of pen input, graphics, database, text, character input, system and communication. The PPSM toolsets, together with its device drivers, provides the basic contro of the LCD, the drawing functions, the real time clock and the UART. The architecture of the embedded system STARTH on the Dragon Ball EZ platform is discussed in parts in details. The development environments of both software and hardware are described. The system is analyzed from its initialization, registration to system management, even the applications programming. The STARTH is tested and run on the hardware system of Dragon Ball platform. It is found that STARTH is practical and reliable for personal information devices.",2000,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=843622,no,
40,Building an IP network quality-of-service testbed,The Drexel Network Toolkit is a software package for testing various approaches to QoS on IP-based networks. It uses Linux and DiffServ packet-marking primitives to classify and prioritize packets. DNT was used in a project to evaluate satellite based IP delivery for multimedia applications in telemedicine and telemaintenance.,2000,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=865089,no,
41,GBS IP multicast tunneling,"Internet protocol (IP) multicast over the DoD's Global Broadcast Service (GBS) provides a one-way communications path to the warfighter as part of an interactive communications system. GBS provides the capability to deliver information products of varying size, timeliness requirements, and security levels. The products share satellite resources based on CINC/JTF commanders priorities, operational locations, availability of the satellite resources, and platform capabilities of the deployed users. Currently, IP multicast (IPMC) is not supported by the Defense Information Infrastructure (DII). This document defines a real-time IP solution for tunneling multicast data across the Defense Information Services Network (DISN), through GBS components, and to the end-user LANs. This paper describes a cost-effective, operationally sound, incremental approach for rapid prototyping and integration of these technologies. It outlines each of the implementation approaches researched to date, the designs selected for systematic testing, and an overview of the plan for testing selected designs. The initial architecture is based on commercial-off-the-shelf IP routers, ATM switches, multicast software, and VPN techniques.",2000,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=904019,no,
42,Generating test cases for GUI responsibilities using complete interaction sequences,"Testing graphical user interfaces (GUI) is a difficult problem due to the fact that the GUI possesses a large number of states to be tested, the input space is extremely large due to different permutations of inputs and events which affect the GUI, and complex GUI dependencies which may exist. There has been little systematic study of this problem yielding a resulting strategy which is effective and scalable. The proposed method concentrates upon user sequences of GUI objects and selections which collaborate, called complete interaction sequences (CIS), that produce a desired response for the user. A systematic method to test these CIS utilizes a finite-state model to generate tests. The required tests can be substantially reduced by identifying components of the CIS that can be tested separately. Since consideration is given to defects totally within each CIS, and the components reduce required testing further, this approach is scalable. An empirical investigation of this method shows that substantial reduction in tests can still detect the defects in the GUI. Future research will prioritize testing related to the CIS testing for maximum benefit if testing time is limited.",2000,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=885865,no,
43,The Digital Library for Earth System Education: implementing the DLESE Community Plan,"Over the past year, geoscience educators, librarians and information technologists have made substantial progress in initiating the construction ofa Digital Library for Earth System Education (DLESE). Two major efforts, the Portal to the Future Workshop and the Geoscience Digital Library (GDL) project, have established a vision for the library, a governance process to enable community ownership, management, and construction, and have begun development of a testbed collection, discovery system, and user interface. The DLESE Community Plan lays out in detail the need for this facility, a community vision for its goals and priorities, and a strategy for initial construction of the library. From this initial work, two conclusions emerge as paramount in moving forward with the library. First, it is essential that development of the library community and the building of the technological infrastructure for the library go hand in hand. Second, the library will be most effectively built as a highly coordinated, but distributed community effort. In this way, the full range of talents in the community can be leveraged and rapid development of the library is possible. This paper briefly reviews our technical accomplishments to date and outlines their plans for further development. Progress and plans can be charted in the following three areas: 1. Community-centered design and use case development 2. Discovery system, metadata, and collection testbeds 3. System architecture and interoperability.",2000,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=860416,no,
44,A hybrid genetic algorithm for generating optimal synthetic aperture radar target servicing strategies,"The purpose of this research was to develop a software tool for generating optimal target servicing strategies for imaging fixed ground targets with a spaceborne SAR. Given a list of targets and their corresponding geographic locations and relative priorities, this tool generates a target servicing strategy that maximizes the overall collection utility based on the number of targets successfully imaged weighted by their relative priorities. This tool is specifically designed to maximize sensor utility in the case of a target-rich environment. For small numbers of targets, a target servicing strategy is unnecessary, and the targets may be imaged in any order without paying any particular attention to geographic proximity or target priority. However, for large, geographically diverse target decks, the order in which targets are serviced is of great importance. The target servicing problem is shown to be of the class NP-hard, and thus cannot be solved to optimality in polynomial time. Therefore, global search techniques such as genetic algorithms are called for. A unique hybrid algorithm that combines genetic algorithms with simulated annealing has been developed to generate optimized target servicing strategies. The performance of this hybrid algorithm was compared against that of three different greedy algorithms in a series of 20 test cases. Preliminary results indicate consistent performance improvements over greedy algorithms for target-rich environments. Over the course of 20 trials, the hybrid optimizing algorithm produced weighted collection scores that were on average 10% higher than the best greedy algorithm.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=931250,no,
45,A selective software testing method based on priorities assigned to functional modules,"As software systems have been introduced to many advanced applications, the size of software systems increases so much. Simultaneously, the lifetime of software systems becomes very small and thus their development is required within a relatively short period. We propose a novel selective software testing method that aims to attain the requirement of short period development. The proposed method consists of 3 steps: assign priorities to functional modules (Step 1), derive a test specification (Step 2), and construct a test plan (Step 3) according to the priorities. In Step 1, for development of functional modules, we select both product and process properties to calculate priorities. Then, in Step 2, we generate detailed test items for each module according to its priority. Finally, in Step 3, we manage test resources including time and developer's skill to attain the requirement. As a result of experimental application, we can show the superiority of the proposed testing method compared to the conventional testing method.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=990028,yes,
46,Air traffic control improvement using prioritized CSMA,"Version 7 simulations of the industry-standard network simulation software ""OPNET"" are presented of two applications of the Aeronautical Telecommunications Network (ATN), Controller Pilot Data Link Communications (CPDLC) and Automatic Dependent Surveillance-Broadcast mode (ADS-B), over VHF Data Link mode 2 (VDL-2). Communication is modeled for air traffic between just three cities. All aircraft are assumed to have the same equipage. The simulation involves Air Traffic Control (ATC) ground stations and 105 aircraft taking off, flying realistic free-flight trajectories, and landing in a 24-hr period. All communication is modeled as unreliable. Collision-less, prioritized carrier sense multiple access (CSMA) is successfully tested. The statistics presented include latency, queue length, and packet loss. This research may show that a communications system simpler than the currently accepted standard envisioned may not only suffice, but also surpass performance of the standard at a lower cost of deployment.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=931366,no,
47,Applying Moore's technology adoption life cycle model to quality of EDA software,"This paper describes a methodology for allocating priority levels and resources to quality activities during the development of EDA software projects. Geoffrey Moore's technology adoption life cycle model is used to provide a baseline understanding of what the market and the target users require at any point in time during the product life cycle. Applying this model, EDA software development teams can make choices and prioritize quality objectives which are based on the customer segment that they are targeting at any point in time during the product life cycle.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=915209,no,
48,DDP-a tool for life-cycle risk management,"At JPL we have developed, and implemented, a process for achieving life-cycle risk management. This process has been embodied in a software tool and is called Defect Detection and Prevention (DDP). The DDP process can be succinctly stated as: determine where we want to be, what could get in the way and how we will get there. The 'determine where we want to be' is captured as trees of requirements and the 'what could get in the way' is captured as trees of potential failure modes. Scoring the impacts of these failure modes on the requirements results in a prioritized set of failure modes. The user then selects from a set of PACTs (Preventative measures, Analyses, process Controls and Tests) each of which has an effectiveness versus the various failure modes. It is the goal of the DDP process to optimally select the subset of the PACTs/spl Dagger/ which minimizes the residual risk subject to the project resource constraints.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=931736,no,
49,Failure modes and effects analysis for software reliability,"This paper presents a systematic problem solving approach, which is based on the failure modes and effects analysis (FMEA), to system software reliability. This approach will practically: (a) ensure that all of conceivable failure modes and their effects on operational success of the software system have been considered; (b) list potential failures, and identify the magnitude of their effects; (c) develop criteria for test planning, design of the tests, and checkout systems (e.g., logging mechanism); (d) provide a basis for quantitative reliability and availability analysis; and (e) provide a basis for establishing corrective action priorities. This approach was created for software reliability analysis and testing in the multimedia digital distribution system (MDDS) at Thomson-CSF Sextant In-Flight Systems. First it was used to improve the software reliability for the ISDN Communication Control Unit (CCU) subsystem of the MDDS, and then globally applied to the software reliability analysis MDDS and improvement for the whole MDDS. It has been proven to be an effective and efficient approach to system software reliability.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=902470,no,
50,Incorporating varying test costs and fault severities into test case prioritization,"Test case prioritization techniques schedule test cases for regression testing in an order that increases their ability to meet some performance goal. One performance goal, rate of fault detection, measures how quickly faults are detected within the testing process. In previous work (S. Elbaum et al., 2000; G. Rothermel et al., 1999), we provided a metric, APFD, for measuring rate of fault detection, and techniques for prioritizing test cases to improve APFD, and reported the results of experiments using those techniques. This metric and these techniques, however, applied only in cases in which test costs and fault severity are uniform. We present a new metric for assessing the rate of fault detection of prioritized test cases that incorporates varying test case and fault costs. We present the results of a case study illustrating the application of the metric. This study raises several practical questions that might arise in applying test case prioritization; we discuss how practitioners could go about answering these questions.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=919106,yes,
51,"Integrated reliability analysis, diagnostics and prognostics for critical power systems","Critical power systems, such as data centers and communication switching facilities, have very high availability requirements (5 min./year downtime). A data center that consumes electricity at a rate of 3 MW can have a downtime cost of $300,000 an hour. Even a momentary interruption of two seconds may cause a loss of two hours of data processing. Consequently, power quality has emerged as an issue of significant importance in the operation of these systems. In this paper, we address three issues of power quality: real-time detection and diagnosis of power quality problems, reliability and availability evaluation, and capacity margin analysis. The objective of real-time detection and diagnosis is to provide a seamless on-line monitoring and off-line maintenance process. The techniques are being applied to monitor the power quality of a few facilities at the University of Connecticut. Reliability analysis, based on a computationally efficient sum of disjoint products, enables analysts to decide on the optimum levels of redundancy, aids operators in prioritizing the maintenance options within a given budget, and in monitoring the system for capacity margin. Capacity margin analysis helps operators to plan for additional loads and to schedule repair/replacement activities. The resulting analytical and software tool is demonstrated on a sample data center.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=949035,no,
52,"Managing the maintenance of ported, outsourced, and legacy software via orthogonal defect classification","From the perspective of maintenance, software systems that include COTS software, legacy, ported or outsourced code pose a major challenge. The dynamics of enhancing or adapting a product to address evolving customer usage and the inadequate documentation of these changes over a period of time (and several generations) are just two of the factors which may have a debilitating effect on the maintenance effort. While many approaches and solutions have been offered to address the underlying problems, few offer methods which directly affect a team's ability to quickly identify and prioritize actions targeting the product which is already in front of them. The paper describes a method to analyze the information contained in the form of defect data and arrive at technical actions to address explicit product and process weaknesses which can be feasibly addressed in the current effort. The defects are classified using Orthogonal Defect Classification (ODC) and actual case studies are used to illustrate the key points.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=972791,no,
53,Prioritizing test cases for regression testing,"Test case prioritization techniques schedule test cases for execution in an order that attempts to increase their effectiveness at meeting some performance goal. Various goals are possible; one involves rate of fault detection, a measure of how quickly faults are detected within the testing process. An improved rate of fault detection during testing can provide faster feedback on the system under test and let software engineers begin correcting faults earlier than might otherwise be possible. One application of prioritization techniques involves regression testing, the retesting of software following modifications; in this context, prioritization techniques can take advantage of information gathered about the previous execution of test cases to obtain test case orderings. We describe several techniques for using test execution information to prioritize test cases for regression testing, including: 1) techniques that order test cases based on their total coverage of code components; 2) techniques that order test cases based on their coverage of code components not previously covered; and 3) techniques that order test cases based on their estimated ability to reveal faults in the code components that they cover. We report the results of several experiments in which we applied these techniques to various test suites for various programs and measured the rates of fault detection achieved by the prioritized test suites, comparing those rates to the rates achieved by untreated, randomly ordered, and optimally ordered suites.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=962562,yes,
54,Providing absolute differentiated services for real-time applications in static-priority scheduling networks,"We propose and analyze a methodology for providing absolute differentiated services for real-time applications in networks that use static-priority schedulers. We extend previous work on worst-case delay analysis and develop a method that can be used to derive delay bounds without specific information on flow population. With this new method, we are able to successfully employ a utilization-based admission control approach for flow admission. This approach does not require explicit delay computation at admission time and hence is scalable to large systems. We assume the underlying network to use static-priority schedulers. We design and analyze several priority assignment algorithms, and investigate their ability to achieve higher utilization bounds. Traditionally, schedulers in differentiated services networks assign priorities on a class-by-class basis, with the same priority for each class on each router. We show that relaxing this requirement, that is, allowing different routers to assign different priorities to classes, achieves significantly higher utilization bounds.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=916255,no,
55,Test-suite reduction and prioritization for modified condition/decision coverage,"Software testing is particularly expensive for developers of high-assurance software, such as software that is produced for commercial airborne systems. One reason for this expense is the Federal Aviation Administration's requirement that test suites be modified condition/decision coverage (MC/DC) adequate. Despite its cost, there is evidence that MC/DC is an effective verification technique, and can help to uncover safety faults. As the software is modified and new test cases are added to the test suite, the test suite grows, and the cost of regression testing increases. To address the test-suite size problem, researchers have investigated the use of test-suite reduction algorithms, which identify a reduced test suite that provides the same coverage of the software, according to some criterion, as the original test suite, and test-suite prioritization algorithms, which identify an ordering of the test cases in the test suite according to some criteria or goals. Existing test-suite reduction and prioritization techniques, however, may not be effective in reducing or prioritizing MC/DC-adequate test suites because they do not consider the complexity of the criterion. The paper presents new algorithms for test-suite reduction and prioritization that can be tailored effectively for use with MC/DC. The paper also presents the results of a case study of the test-suite reduction algorithm.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=972715,no,
56,The importance of quality requirements in software platform development-a survey,"This paper presents a survey where some quality requirements that commonly affect software architecture have been prioritized with respect to cost and lead-time impact when developing software platforms and when using them. Software platforms are the basis for a product-line, i.e. a collection of functionality that a number of products is based on. The survey has been carried out in two large software development organizations using 34 senior participants. The prioritization was carried out using the Incomplete Pairwise Comparison method (IPC). The analysis shows that there are large differences between the importance of the quality requirements studied. The differences between the views of different stakeholders are also analysed and it is found to be less than the difference between the quality requirements. Yet this is identified as a potential source of negative impact on product development cost and lead-time, and rules of thumb for reducing the impact are given.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=927252,no,
57,Understanding and measuring the sources of variation in the prioritization of regression test suites,"Test case prioritization techniques let testers order their test cases so that those with higher priority, according to some criterion, are executed earlier than those with lower priority. In previous work (1999, 2000), we examined a variety of prioritization techniques to determine their ability to improve the rate of fault detection of test suites. Our studies showed that the rate of fault detection of test suites could be significantly improved by using more powerful prioritization techniques. In addition, they indicated that rate of fault detection was closely associated with the target program. We also observed a large quantity of unexplained variance, indicating that other factors must be affecting prioritization effectiveness. These observations motivate the following research questions. (1) Are there factors other than the target program and the prioritization technique that consistently affect the rate of fault detection of test suites? (2) What metrics are most representative of each factor? (3) Can the consideration of additional factors lead to more efficient prioritization techniques? To address these questions, we performed a series of experiments exploring three factors: program structure, test suite composition and change characteristics. This paper reports the results and implications of those experiments.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=915525,yes,
58,Yemanja-a layered event correlation engine for multi-domain server farms,"Yemanja is a model-based event correlation engine for multi-layer fault diagnosis. It targets complex propagating fault scenarios, and can smoothly correlate low-level network events with high-level application performance alerts related to quality of service violations. Entity-models that represent devices or abstract components encapsulate entity behavior. Distantly associated entities are not explicitly aware of each other, and communicate through event propagation chains. Yemanja's state-based engine supports generic scenario definitions, prioritization of alternate solutions, integrated problem-state and device testing, and simultaneous analysis of overlapping problems. The system of correlation rules was developed based on device, layer, and dependency analysis, and reveals the layered structure of computer networks. The primary objectives of this research include the development of reusable, configuration independent, correlation scenarios; adaptability and the extensibility of the engine to match the constantly changing topology of a multi-domain server farm; and the development of a concise specification language that is relatively simple yet powerful.",2001,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=918051,no,
59,A history-based test prioritization technique for regression testing in resource constrained environments,"Regression testing is an expensive and frequently executed maintenance process used to revalidate modified software. To improve it, regression test selection (RTS) techniques strive to lower costs without overly reducing effectiveness by carefully selecting a subset of the test suite. Under certain conditions, some can even guarantee that the selected test cases perform no worse than the original test suite. This ignores certain software development realities such as resource and time constraints that may prevent using RTS techniques as intended (e.g., regression testing must be done overnight, but RTS selection returns two days worth of tests). In practice, testers work around this by prioritizing the test cases and running only those that fit within existing constraints. Unfortunately this generally violates key RTS assumptions, voiding RTS technique guarantees and making regression testing performance unpredictable. Despite this, existing prioritization techniques are memoryless, implicitly assuming that local choices can ensure adequate long run performance. Instead, we propose a new technique that bases prioritization on historical execution data. We conducted an experiment to assess its effects on the long run performance of resource constrained regression testing. Our results expose essential tradeoffs that should be considered when using these techniques over a series of software releases.",2002,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1007961,yes,
60,"Analysis of preemptive periodic real-time systems using the (max, plus) algebra with applications in robotics","We present the model of a system of periodic real-time tasks with fixed priorities, preemption and synchronization, performed by a robot controller, using marked graphs. Then, with the help of the (max, plus) algebra, we derive simple tests to check real-time constraints on those tasks such as response times and the respect of deadlines. This method takes into account the precedence and synchronization constraints and is not limited to a particular scheduling policy.",2002,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=998024,no,
61,Dual purpose simulation: new data link test and comparison with VDL-2,"While the results of this paper are similar to those of previous research, in this paper the technical difficulties present previously are eliminated, producing better results, enabling one to more readily see the benefits of Prioritized CSMA (PCSMA). A new analysis section also helps to generalize this research so that it is not limited to exploration of the new concept of PCSMA. Commercially available network simulation software, OPNET version 7.0, simulations are presented involving an important application of the Aeronautical Telecommunications Network (ATN), Controller Pilot Data Link Communications (CPDLC) over the Very High Frequency Data Link Mode 2 (VDL-2). Communication is modeled for essentially all incoming and outgoing nonstop air-traffic for just three United States cities: Cleveland, Cincinnati, and Detroit. Collision-less PCSMA is successfully tested and compared with the traditional CSMA typically associated with VDL-2. The performance measures include latency, throughput, and packet loss. As expected, PCSMA is much quicker and more efficient than traditional CSMA. These simulation results show the potency of PCSMA for implementing low latency, high throughput and efficient connectivity. We are also testing a new and better data link that could replace CSMA with relative ease.",2002,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1067949,no,
62,Elimination of crucial faults by a new selective testing method,"Recent software systems contain a lot of functions to provide various services. According to this tendency, software testing becomes more difficult than before and cost of testing increases so much, since many test items are required. In this paper we propose and discuss such a new selective software testing method that is constructed from previous testing method by simplifying testing specification. We have presented, in the previous work, a selective testing method to perform highly efficient software testing. The selective testing method has introduced an idea of functional priority testing and generated test items according to their functional priorities. Important functions with high priorities are tested in detail, and functions with low priorities are tested less intensively. As a result, additional cost for generating testing instructions becomes relatively high. In this paper in order to reduce its cost, we change the way of giving information, with respect to priorities. The new method gives the priority only rather than generating testing instructions to each test item, which makes the testing method quite simple and results in cost reduction. Except for this change, the new method is essentially the same as the previous method. We applied this new method to actual development of software tool and evaluated its effectiveness. From the result of the application experiment, we confirmed that many crucial faults can be detected by using the proposed method.",2002,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1166937,no,
63,Extreme programming modified: embrace requirements engineering practices,"Extreme programming (XP) is an agile (lightweight) software development methodology and it becomes more and more popular. XP proposes many interesting practices, but it also has some weaknesses. From the software engineering point of view the most important issues are: maintenance problems resulting from very limited documentation (XP relies on code and test cases only), and lack of wider perspective of a system to be built. Moreover, XP assumes that there is only one customer representative. In many cases there are several representatives (each one with his own view of the system and different priorities) and then some XP practices should be modified. In the paper we assess XP from two points of view: the capability maturity model and the Sommerville-Sawyer model (1997). We also propose how to introduce documented requirements to XP, how to modify the planning game to allow many customer representatives and how to get a wider perspective of a system to be built at the beginning of the project lifecycle.",2002,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1048543,no,
64,How much information is needed for usage-based reading? A series of experiments,"Software inspections are regarded as an important technique to detect faults throughout the software development process. The individual preparation phase of software inspections has enlarged its focus from only comprehension to also include fault searching. Hence, reading techniques to support the reviewers on fault detection are needed. Usage-based reading (UBR) is a reading technique, which focuses on the important parts of a software document by using prioritized use cases. This paper presents a series of three UBR experiments on design specifications, with focus on the third. The first experiment evaluates the prioritization of UBR and the second compares UBR against checklist-based reading. The third experiment investigates the amount of information needed in the use cases and whether a more active approach helps the reviewers to detect more faults. The third study was conducted at two different places with a total of 82 subjects. The general result from the experiments is that UBR works as intended and is efficient as well as effective in guiding reviewers during the preparation phase of software inspections. Furthermore, the results indicate that use cases developed in advance are preferable compared to developing them as part of the preparation phase of the inspection.",2002,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1166932,no,
65,ICT in Japanese university language education: a case study,This paper reports part of a study conducted at a university in Japan. The belief that ICT provides students with more opportunities to negotiate target forms has been used to justify its use in language education. This study could not substantiate that ICT will change the way language is used in Japan or that CALL is providing new ways for learning and acquiring a new language. Students were experiencing difficulties in prioritising their learning repertoire between the acquisition of computer skills and language proficiency. Individuals experienced positive and negative coding and de-coding filters when communicating in ICT and this was related to the validity and reliability applied to the text. The value attached to the ICT interaction may influence the degree to which the ICT event influences face-to-face communicative acts.,2002,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1186116,no,
66,Maintaining software with a security perspective,"Testing for software security is a lengthy, complex and costly process. Currently, security testing is done using penetration analysis and formal verification of security kernels. These methods are not complete and are difficult to use. Hence it is essential to focus testing effort in areas that have a greater number of security vulnerabilities to develop secure software as well as meet budget and time constraints. We propose a testing strategy based on a classification of vulnerabilities to develop secure and stable systems. This taxonomy will enable a system testing and maintenance group to understand the distribution of security vulnerabilities and prioritize their testing effort according to the impact the vulnerabilities have on the system. This is based on Landwehr's (1994) classification scheme for security flaws and we evaluated it using a database of 1360 operating system vulnerabilities. This analysis indicates vulnerabilities tend to be focused in relatively few areas and associated with a small number of software engineering issues.",2002,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1167766,no,
67,Modeling the cost-benefits tradeoffs for regression testing techniques,"Regression testing is an expensive activity that can account for a large proportion of the software maintenance budget. Because engineers add tests into test suites as software evolves, over time, increased test suite size makes revalidation of the software more expensive. Regression test selection, test suite reduction, and test case prioritization techniques can help with this, by reducing the number of regression tests that must be run and by helping testers meet testing objectives more quickly. These techniques, however can be expensive to employ and may not reduce overall regression testing costs. Thus, practitioners and researchers could benefit from cost models that would help them assess the cost-benefits of techniques. Cost models have been proposed for this purpose, but some of these models omit important factors, and others cannot truly evaluate cost-effectiveness. In this paper, we present new cost-benefits models for regression test selection, test suite reduction, and test case prioritization, that capture previously omitted factors, and support cost-benefits analyses where they were not supported before. We present the results of an empirical study assessing these models.",2002,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1167767,yes,
68,Parameter optimization tool for enhancing on-chip network performance,"In this paper, we present a tool to be used in the optimization of interconnection parameters in order to achieve optimal performance and implementation with minimal costs. The optimization tool uses an iterative algorithm to optimize the interconnection parameters, such as data width, priorities, and the time an agent can reserve the interconnection, to fulfill the given constraints. In the used test case, the required area decreased 50% while 85% of the original bandwidth was obtained. This was due to an improved arbitration process.",2002,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1010388,no,
69,Simulation of restaurant operations using the Restaurant Modeling Studio,"The operation of quick service restaurants (QSR) is a highly engineered process, with many factors coming into play: physical layout, equipment availability, and worker staffing levels, positioning, and priorities. The Restaurant Modeling Studio (RMS) provides an analysis platform for investigating the impacts of these factors on critical performance metrics, especially speed of service and service capacity. The key components of the RMS are a simulation engine built in Arena, and two custom applications built on Microsoft Visio - the Kitchen and Process Designers. The simulation engine supports a large number of behaviors, including parallel operations, inventory replenishment, prioritized task selection and many more. The Kitchen Designer and Process Designer provide the user with powerful tools for specifying the physical layout and order fulfillment processes. This paper presents the components of the RMS and its use in an analysis kitchen design comparison and labor deployment standards.",2002,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1166417,no,
70,Test case prioritization: a family of empirical studies,"To reduce the cost of regression testing, software testers may prioritize their test cases so that those which are more important, by some measure, are run earlier in the regression testing process. One potential goal of such prioritization is to increase a test suite's rate of fault detection. Previous work reported results of studies that showed that prioritization techniques can significantly improve rate of fault detection. Those studies, however, raised several additional questions: 1) Can prioritization techniques be effective when targeted at specific modified versions; 2) what trade-offs exist between fine granularity and coarse granularity prioritization techniques; 3) can the incorporation of measures of fault proneness into prioritization techniques improve their effectiveness? To address these questions, we have performed several new studies in which we empirically compared prioritization techniques using both controlled experiments and case studies.",2002,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=988497,yes,
71,A comparison of coverage-based and distribution-based techniques for filtering and prioritizing test cases,"This paper presents an empirical comparison of four different techniques for filtering large test suites: test suite minimization, prioritization by additional coverage, cluster filtering with one-per-cluster sampling, and failure pursuit sampling. The first two techniques are based on selecting subsets that maximize code coverage as quickly as possible, while the latter two are based on analyzing the distribution of the tests' execution profiles. These techniques were compared with data sets obtained from three large subject programs: the GCC, Jikes, and javac compilers. The results indicate that distribution-based techniques can be as efficient or more efficient for revealing defects than coverage-based techniques, but that the two kinds of techniques are also complementary in the sense that they find different defects. Accordingly, some simple combinations of these techniques were evaluated for use in test case prioritization. The results indicate that these techniques can create more efficient prioritizations than those generated using prioritization by additional coverage.",2003,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1251065,yes,
72,A task space redundancy-based scheme for motion planning,"In many applications, the manipulations require only part of the degrees of freedom (DOFs) of the end-effector, or some DOFs are more important than the rest. We name these applications prioritized manipulations. The end-effectors DOFs are divided into those which are critical and must be controlled as precisely as possible, and those which have loose specifications, so their tracking performance can traded-off to achieve other needs. In this paper, we derive a formulation for partitioning the task space into major and secondary task directions and finding the velocity and static force mappings that precisely accomplish the major task and locally optimize some secondary goals. The techniques are tested on a 6-DOF parallel robot performing a 2-DOF tracking task.",2003,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1244063,no,
73,"Generating, selecting and prioritizing test cases from specifications with tool support","The classification-tree method provides a systematic way for software testers to derive test cases by considering important relevant aspects that are identified from the specification. The method has been used in many real-life applications and shown to be effective. This paper presents several enhancements to the method by annotating the classification tree with additional information to reduce manual effort in the generation, selection and prioritization of test cases. A tool for supporting this enhanced process is also described.",2003,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1319089,yes,
74,Global implementation of ERP software - critical success factors on upgrading technical infrastructure,"Implementing an Enterprise Resource planning (ERP) software in a global environment, executive sponsors face two key challenges. While business processes are to be re-engineered to align with the ERP software best practices, technical architecture and infrastructure needs to be in place globally as per specifications of the packaged software. In the legacy environment, different countries or different business units use different systems, based on local standards supported by local resources. In the new ERP world, globally all the countries must conform to same technical infrastructure. Technical managers face multiple critical issues implementing a global solution. Most of the ERP software are developed in technically advanced countries, standards are often too high for under developed or developing countries. In an effort to bring the global organization to a common platform different countries needs different levels of upgrades. In this paper the authors review key technical issues faced is a global upgrade process to support a global ERP implementation and how to resolve those. We conclude although technical infrastructure and business process reengineering both are equally important and each implementation is unique, but following some simple steps it is easy to prioritize each ones during different phases of the project. Also time lines of two sub-projects must converge after initial phase and must follow a common plan for the project to be successful. Multiple scenarios are described to facilitate the process.",2003,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1252285,no,
75,Global multiprocessor scheduling of aperiodic tasks using time-independent priorities,"We provide a constant time schedulability test for a multiprocessor server handling aperiodic tasks. Dhall's effect is avoided by dividing the tasks in two priority classes based on task utilization: heavy and light. We prove that if the load on the multiprocessor server stays below U/sub threshold/ = 3 - /spl radic/7 = 35.425%, the server can accept incoming aperiodic tasks and guarantee that the deadlines of all accepted tasks will be met. 35.425% utilization is also a threshold for a task to be characterized as heavy. The bound U/sub threshold/ = 3 - /spl radic/7 = 35.425% is easy-to-use, but not sharp if we know the number of processors in the multiprocessor. For a server with m processors, we calculate a formula for the sharp bound U/sub threshold/(m), which converges to Uthreshold from above as m - -. The results are based on a utilization function u/sub m/(x) = 2(1 - x)/(2 + /spl radic/(2 + 2x)) + x/m. By using this function, the performance of the multiprocessor can in some cases be improved beyond U/sub threshold/ (m) by paying the extra overhead of monitoring the individual utilization of the current tasks.",2003,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1203049,no,
76,Market-based task allocation for dynamic processing environments,"Flexible and large-scale information processing across enterprises entails dynamic and decentralized control of workflow through adaptive allocation of knowledge and processing resources. Markets comprise a well-understood class of mechanisms for decentralized resource allocation, where agents interacting through a price system direct resources toward their most valued uses as indicated by these prices. The information-processing domain presents several challenges for market-based approaches, including (1) representing knowledge-intensive tasks and capabilities, (2) propagating price signals across multiple levels of information processing, (3) handling dynamic task arrival and changing priorities, and (4) accommodating the increasing-returns and public-good characteristics of information products. A market gaming environment provides a methodology for testing alternative market structures and agent strategies, and evaluating proposed solutions in a realistic decentralized manner.",2003,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1245031,no,
77,Prioritized use cases as a vehicle for software inspections,"The usage-based reading technique combines traditional inspection principles, use cases, and operational profile testing to create an efficient user-oriented software inspection reading technique. UBR can find faults more effectively and efficiently than the traditional checklist-based method.",2003,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1207451,no,
78,Putting your best tests forward,"Test case prioritization orders tests so that they help you meet your testing goals earlier during regression testing. Prioritization techniques can, for example, order tests to achieve coverage at the fastest rate possible, exercise features in order of expected frequency of use, or reveal faults as early as possible. We focus on the last goal, which we describe as ""increasing a test suite's rate of fault detection"" or the speed with which the test suite reveals faults. A faster fault detection rate during regression testing provides earlier feedback on a system under test, supporting earlier strategic decisions about release schedules and letting engineers begin debugging sooner. Also, if testing time is limited or unexpectedly reduced, prioritization increases the chance that testing resources will have been spent as cost effectively as possible in the available time.",2003,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1231157,yes,
79,Smart debugging software architectural design in SDL,"Statistical data show that it is much less expensive to correct software bugs at the early design stage rather than the late stage of the development process when the final system has already been implemented and integrated together. The use of slicing and execution histories as an aid in software debugging is well established for programming languages like C and C++; however, it is rarely applied in the field of software design specification. We propose a solution by applying the source code level technologies to debugging software designs represented in a high-level specification and description language such as SDL. More specifically, we extend execution slice-based heuristics from source code-based debugging to the software design specification level. Suspicious locations in an SDL specification are prioritized by their likelihood of containing faults. Locations with a higher priority should be examined first rather than those with a lower priority as the former are more likely to contain the faults. A debugging tool, SmartD/sub DSL/, with user-friendly interfaces was developed to support our method. An illustration is provided to demonstrate the feasibility of using our method to effectively debug an architectural design.",2003,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1245320,no,
80,Test-suite reduction and prioritization for modified condition/decision coverage,"Software testing is particularly expensive for developers of high-assurance software, such as software that is produced for commercial airborne systems. One reason for this expense is the Federal Aviation Administration's requirement that test suites be modified condition/decision coverage (MC/DC) adequate. Despite its cost, there is evidence that MC/DC is an effective verification technique and can help to uncover safety faults. As the software is modified and new test cases are added to the test suite, the test suite grows and the cost of regression testing increases. To address the test-suite size problem, researchers have investigated the use of test-suite reduction algorithms, which identify a reduced test suite that provides the same coverage of the software according to some criterion as the original test suite, and test-suite prioritization algorithms, which identify an ordering of the test cases in the test suite according to some criteria or goals. Existing test-suite reduction and prioritization techniques, however, may not be effective in reducing or prioritizing MC/DC-adequate test suites because they do not consider the complexity of the criterion. This paper presents new algorithms for test-suite reduction and prioritization that can be tailored effectively for use with MC/DC. The paper also presents the results of empirical studies of these algorithms.",2003,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1183927,yes,
81,Web-technology of university's evaluation rating,"At present there is no a unified standard system of both qualitative and quantitative criteria to estimate objectively the conformity of the University activities and its infrastructure with the requirements of the public state attestation and accreditation. So the use of heuristic and expert procedures is considered to be necessary. In the suggested model of the University (institute, faculty, department) rating, the fragments of the models used by the Ministry of Education of Russia, the Association for Technical Universities of Russia, the Independent Accreditation Center, the advanced technical universities of Russia, as well as long-term developments of the Tomsk Polytechnic University in quality control of the University activities and its departments, modern tendencies and priorities of the universities developments, are accepted as the basic ones. 55 indices have been determined. Numerical values of indices are normalized on the maximum value achieved in the objects under consideration that provides a commensurability of indices by their essential spread in various objects. The data convolution by sections and subsections is carried out linearly taking into account their importance. The value of the index is determined by an expert method taking into account its relative importance within the limits of each section (subsection). The numerical value of each rating index is determined by its relation to the ""base"". The ""base"" is determined as the on-budget salary fund of the University (institute, faculty, department) staff, providing educational process, and the on-budget salary fund of the staff carrying out state budgetary research. The software for the collective interactive remote input of the indices, as well as for the centralized calculation and operative analysis of the universities rating has been developed. The server Apache, the database server MySQL, and the scripting language PHP have been used for the above work to be carried out.",2003,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1222647,no,
82,Agile development: evaluation and experience,"Agile methods such as Extreme Programming, Crystal, Scrum, and others have attracted a lot of attention recently. Agile methods stress early and continuous delivery of software, welcome changing requirements, and value early feedback from customers. Agile methods seek to cut out inefficiency, bureaucracy, and anything that adds no value to a software product. Proponents of agile methods often see software specification and documentation as adding no value, which has led observers to conclude that agile development is nothing but unprincipled hacking, perhaps even an anarchic counter-reaction to bureaucratic, heavyweight software processes that demand ever more intermediate deliverables from developers. The purpose of this panel is to discuss under what circumstances agile methods work and don't work. Some of the key practices of agile methods are: scheduling according to feature priorities, incremental delivery of software, feedback from expert users, emphasis on face-to-face communication, pair development, minimalist design combined with refactoring, test-driven development, automated regression testing, daily integration, self-organizing teams, and periodic tuning of the methods. Working software is the primary measure of success. Find out what the latest practical experience with agile methods is and learn about the latest thinking in this area.",2004,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1317492,no,
83,An approach to generate the thin-threads from the UML diagrams,"Software testing plays a crucial role in assuring software quality. One of the most important issues in software testing research is the generation of the test cases. For scenario-based software testing, the thin-threads, which are the usage scenarios in a software system from the end user's point of view, are frequently used to generate test cases. However, the generation of the thin-threads is not an easy task. A scenario-based business model has to be manually derived or labor-intensive business analysis has to be manually carried out in order to extract the thin-threads from a software system. In this work, we propose an automated approach to directly generate thin-threads from the UML artifacts. The generated thin-threads can be used to generate and to prioritize the test cases for scenario-based software testing.",2004,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1342893,no,
84,An execution slice and inter-block data dependency-based approach for fault localization,"Localizing a fault in a program is a complex and time-consuming process. In this paper we present a novel approach using execution slice and inter-block data dependency to effectively identify the locations of program faults. An execution slice with respect to a given test case is the set of code executed by this test, and two blocks are data dependent if one block contains a definition that is used by another block or vice versa. Not only can our approach reduce the search domain for program debugging, but also prioritize suspicious locations in the reduced domain based on their likelihood of containing faults. More specifically, the likelihood of a piece of code containing a specific fault is inversely proportional to the number of successful tests that execute it. In addition, the likelihood also depends on whether this piece of code is data dependent on other suspicious code. A debugging tool, DESiD, was developed to support our method. A case study that shows the effectiveness of our method in locating faults on an application developed for the European Space Agency is also reported.",2004,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1371939,no,
85,An improved AHP method in performance assessment,"In order to reduce subjective errors in the traditional analytic hierarchy process (AHP), an improved AHP method integrated with orthogonal experimental design was presented in this paper. The new method combined both AHP and orthogonal design principles to make decisions, objectives in assessment system and values computed through mapping and satisfying function respectively as the corresponding factors, levels and results in orthogonal experimental design. With software SAS analysis, priorities on performance were to be ranked out accordingly. Application has showed that the method can improve the accuracy of AHP in performance assessment.",2004,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1340551,no,
86,Assessing staffing needs for a software maintenance project through queuing simulation,"We present an approach based on queuing theory and stochastic simulation to help planning, managing, and controlling the project staffing and the resulting service level in distributed multiphase maintenance processes. Data from a Y2K massive maintenance intervention on a large COBOL/JCL financial software system were used to simulate and study different service center configurations for a geographically distributed software maintenance project. In particular, a monolithic configuration corresponding to the customer's point-of-view and more fine-grained configurations, accounting for different process phases as well as for rework, were studied. The queuing theory and stochastic simulation provided a means to assess staffing, evaluate service level, and assess the likelihood to meet the project deadline while executing the project. It turned out to be an effective staffing tool for managers, provided that it is complemented with other project-management tools, in order to prioritize activities, avoid conflicts, and check the availability of resources.",2004,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1265735,no,
87,Aviation application over IPv6: performance issues,"Aviation industries in United States and in Europe are undergoing a major paradigm shift in the introduction of new network technologies. In the US, NASA is also actively investigating the feasibility of IPv6 based networks for the aviation needs of the United States. In Europe, the Eurocontrol lead, Internet protocol for aviation exchange (iPAX) Working Group is actively investigating the various ways of migrating the aviation authorities backbone infrastructure from X.25 based networks to an IPv6 based network. For the last 15 years, the global aviation community has pursued the development and implementation of an industry-specific set of communications standards known as the aeronautical telecommunications network (ATN). These standards are now beginning to affect the emerging military global air traffic management (GATM) community as well as the commercial air transport community. Efforts are continuing to gain a full understanding of the differences and similarities between ATN and Internet architectures as related to communications, navigation, and surveillance (CNS) infrastructure choices. This research paper describes the implementation of the IPv6 testbed at Computer Networks & Software, Inc. and it's interface connection mechanism to Eurocontrol and NASA's (Cleveland) testbed in the first phase of the project. In the second phase this research work investigates the performance issues of aviation applications such as controller to pilot data link communication (CPDLC), on an IPv6 based backbone network. Aviation applications are grouped into different priority levels. Desired quality of service (QoS) to each priority level is implemented via Diffserv implementation. This research work looks into the possibility of providing similar QoS performance for aviation application in an IPv6 network as is provided in an ATN based network. The testbed consists of three autonomous systems. The autonomous system represents CNS domain, NASA domain and a EUROCONTROL domain. The primary mode of connection between CNS IPv6 testbed and NASA and EUROCONTROL IPv6 testbed is initially a set of IPv6 over IPv4 tunnels. The aviation application under test (CPDLC) consists of two processes running on different IPv6 enabled machines. These processes communicate with each other over the IPv6 network. One machine resides on the CNS portion of the testbed and other may reside in NASA (Cleveland) and/or in Eurocontrol. The IPv6 packets between Eurocontrol, NASA and CNS testbeds would be carried on IPv6 over IPv4 tunnels. We present some results, which suggest that IPv6 QoS has matured enough, so as to provide the QoS service, which is similar in capability to die ATN architecture. We implemented three basic priorities of flow: (1) command & control; (2) surveillance; and (3) general traffic. Various parameters like throughput, packet loss and delay are investigated. The results are analyzed to get a conceptual view of the effect of IPv6 based network on the aviation applications.",2004,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1367941,no,
88,Best practices for a FRACAS implementation,"Many companies use a FRACAS (failure reporting analysis and corrective action system) process, better known as a closed-loop analysis and correction action process, to track and report problems or failures. Very few companies, however, fully realize all of the possible benefits of a FRACAS process, such as improving quality and productivity while reducing costs. Although many issues may prevent an effective implementation, there are three areas of concern that may cause negative impacts irrespective of the best-intentioned technology. In particular, complex organization interaction, inefficient and ineffective data tracking, and a lack of prioritized goals prevent the dramatic results that can be achieved with a FRACAS. By following the suggested eight step methodology and best practices presented, the potential for implementing a high-performance FRACAS can be greatly increased.",2004,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1285523,no,
89,Code-coverage guided prioritized test generation,"With Internet applications spreading like wildfire, software testing is challenged with new topics related to the distributed nature of Web applications. We apply code based testing techniques to the testing of Web applications, specifically Java programs. Source code based automatic test generation is difficult because most previous methods use constraint satisfaction models as a solution, which is an NP complete problem [M. J. Gallagher et al. (1997)]. We present a method of guiding users through test case generations. Instead of automating the entire procedure, our method aims at generating a framework of test cases and providing instructions for users to instantiate the framework into actual executable test cases. An early experimental study of this method shows the effectiveness of this method.",2004,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1342705,no,
90,Empirical studies of test case prioritization in a JUnit testing environment,"Test case prioritization provides a way to run test cases with the highest priority earliest. Numerous empirical studies have shown that prioritization can improve a test suite's rate of fault detection, but the extent to which these results generalize is an open question because the studies have all focused on a single procedural language, C, and a few specific types of test suites, in particular, Java and the JUnit testing framework are being used extensively in practice, and the effectiveness of prioritization techniques on Java systems tested under JUnit has not been investigated. We have therefore designed and performed a controlled experiment examining whether test case prioritization can be effective on Java programs tested under JUnit, and comparing the results to those achieved in earlier studies. Our analyses show that test case prioritization can significantly improve the rate of fault detection of JUnit test suites, but also reveal differences with respect to previous studies that can be related to the language and testing paradigm.",2004,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1383111,yes,
91,New optical switches enable automated testing with true flexibility,"The proliferation of fiber optic systems in military and avionics platforms is driven by the ever increasing need for higher data rates to support multi-sensor data fusion. Traditionally, the test systems to support these optical deployments are manual and inefficient. Increasingly fast optical components require optical test equipment that is very expensive. To make cost effective test suites, it is essential that these high value resources be used efficiently. This is most effectively accomplished through test architectures that are remotely controlled and automatically scheduled. These test architectures also enable a diverse set of testing applications to be simultaneously executed within an optical test lab or manufacturing environment. The advent of optical matrix switching technology with sub 1dB insertion loss performance and repeatability measured in milli dB's opens up new doors for highly efficient, remotely controlled, automated test systems. The ultra low loss aspects of these switches enable distributed test architectures that were previously unrealizable. Distributed test architectures create a test environment where expensive test equipment can be leveraged over a greater number of test samples in a more timely and automated fashion. This allows the lab manager to prioritize and schedule tests across many users, DUTs, and test equipment bays in an operation that can run 24/7. This paper explores the enabling photonic switch technology and a couple generic test architectures that can be applied in a variety of automated applications to increase test equipment usage and efficiency, thus lowering end costs for deployable fiber optic components and systems.",2004,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1436883,no,
92,Requirements driven software evolution,"Software evolution is an integral part of the software life cycle. Furthermore in the recent years the issue of keeping legacy systems operational in new platforms has become critical and one of the top priorities in IT departments worldwide. The research community and the industry have responded to these challenges by investigating and proposing techniques for analyzing, transforming, integrating, and porting software systems to new platforms, languages, and operating environments. However, measuring and ensuring that compliance of the migrant system with specific target requirements have not been formally and thoroughly addressed. We believe that issues such as the identification, measurement, and evaluation of specific re-engineering and transformation strategies and their impact on the quality of the migrant system pose major challenges in the software re-engineering community. Other related problems include the verification, validation, and testing of migrant systems, and the design of techniques for keeping various models (architecture, design, source code) during evolution, synchronized. In this working session, we plan to assess the state of the art in these areas, discuss on-going work, and identify further research issues.",2004,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311070,no,
93,A controlled experiment assessing test case prioritization techniques via mutation faults,"Regression testing is an important part of software maintenance, but it can also be very expensive. To reduce this expense, software testers may prioritize their test cases so that those that are more important are run earlier in the regression testing process. Previous work has shown that prioritization can improve a test suite's rate of fault detection, but the assessment of prioritization techniques has been limited to hand-seeded faults, primarily due to the belief that such faults are more realistic than automatically generated (mutation) faults. A recent empirical study, however, suggests that mutation faults can be representative of real faults. We have therefore designed and performed a controlled experiment to assess the ability of prioritization techniques to improve the rate of fault detection techniques, measured relative to mutation faults. Our results show that prioritization can be effective relative to the faults considered, and they expose ways in which that effectiveness can vary with characteristics of faults and test suites. We also compare our results to those collected earlier with respect to the relationship between hand-seeded faults and mutation faults, and the implications this has for researchers performing empirical studies of prioritization.",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510136,yes,
94,Concealment of whole-frame losses for wireless low bit-rate video based on multiframe optical flow estimation,"In low bit-rate packet-based video communications, video frames may have very small size, so that each frame fills the payload of a single network packet; thus, packet losses correspond to whole-frame losses, to which the existing error concealment algorithms are badly suited and generally not applicable. In this paper, we deal with the problem of concealment of whole frame-losses, and propose a novel technique which is capable of handling this very critical case. The proposed technique presents other two major innovations with respect to the state-of-the-art: i) it is based on optical flow estimation applied to error concealment and ii) it performs multiframe estimation, thus optimally exploiting the multiple reference frame buffer featured by the most modern video coders such as H.263+ and H.264. If data partitioning is employed, by e.g., sending headers, motion vectors, and coding modes in prioritized packets as can be done in the DiffServ network model, the algorithm is capable of exploiting the motion vectors to improve the error concealment results. The algorithm has been embedded in the H.264 test model software, and tested under both independent and correlated packet loss models with parameters typical of the wireless environment. Results show that the proposed algorithm significantly outperforms other techniques by several dBs in peak signal-to-noise ratio (PSNR), provides good visual quality, and has a rather low complexity, which makes it possible to perform real-time operation with reasonable computational resources.",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1407904,no,
95,Current results from a rover science data analysis system,"The Onboard Autonomous Science Investigation System (OASIS) evaluates geologic data gathered by a planetary rover. This analysis is used to prioritize the data for transmission, so that the data with the highest science value is transmitted to Earth. In addition, the onboard analysis results are used to identify science opportunities. A planning and scheduling component of the system enables the rover to take advantage of the identified science opportunity. OASIS is a NASA-funded research project that is currently being tested on the FIDO rover at JPL for use on future missions. In this paper, we provide a brief overview of the OASIS system, and then describe our recent successes in integrating with and using rover hardware. OASIS currently works in a closed loop fashion with onboard control software (e.g., navigation and vision) and has the ability to autonomously perform the following sequence of steps: analyze gray scale images to find rocks, extract the properties of the rocks, identify rocks of interest, retask the rover to take additional imagery of the identified target and then allow the rover to continue on its original mission. We also describe the early 2004 ground test validation of specific OASIS components on selected Mars exploration rover (MER) images. These components include the rock-finding algorithm, RockIT, and the rock size feature extraction code. Our team also developed the RockIT GUI, an interface that allows users to easily visualize and modify the rock-finder results. This interface has allowed us to conduct preliminary testing and validation of the rock-finder's performance.",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1559328,no,
96,Early community building: a critical success factor for XP projects,"Extreme programming (XP) literature and discussions often view successful projects only as customer-driven product development: planning, coding and testing an unfolding series of prioritized units of vertical functionality. I claim, however, that a successful project also requires a prospering community, comprising an introspective group of committed professionals communicating effectively, and using a well-understood, stable process. Weakness on any of these fronts presents a high risk of failure; therefore, I advise every XP project's members to actively engage in building their community, such that it reaches its critical level of development already by the first internal release. To help in this endeavor, I provide a comprehensive list of activities and attitudes to practice and avoid during the first release.",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1609817,no,
97,Empirical results from an experiment on value-based review (VBR) processes,"As part of our research on value-based software engineering, we conducted an experiment on the use of value-based review (VBR) processes. We developed a set of VBR checklists with issues ranked by success-criticality, and a set of VBR processes prioritized by issue criticality and stakeholder-negotiated product capability priorities. The experiment involved 28 independent verification and validation (IV&V) subjects (full-time working professionals taking a distance learning course) reviewing specifications produced by 18 real-client, full-time student e-services projects. The IV&V subjects were randomly assigned to use either the VBR approach or our previous value-neutral checklist-based reading (CBR) approach. The difference between groups was not statistically significant for number of issues reported, but was statistically significant for number of issues per review hour, total issue impact, and cost effectiveness in terms of total issue impact per review hour. For the latter, the VBRs were roughly twice as cost-effective as the CBRs.",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1541809,no,
98,Identification of test process improvements by combining fault trigger classification and faults-slip-through measurement,"Successful software process improvement depends on the ability to analyze past projects and determine which parts of the process that could become more efficient. One source of such an analysis is the faults that are reported during development. This paper proposes how a combination of two existing techniques for fault analysis can be used to identify where in the test process improvements are needed, i.e. to pinpoint which activities in which phases that should be improved. This was achieved by classifying faults after which test activities that triggered them and which phase each fault should have been found in, i.e. through a combination of orthogonal defect classification (ODC) and faults-slip-through measurement. As a part of the method, the paper proposes a refined classification scheme due to identified problems when trying to apply ODC classification schemes in practice. The feasibility of the proposed method was demonstrated by applying it on an industrial software development project at Ericsson AB. The obtained measures resulted in a set of quantified and prioritized improvement areas to address in consecutive projects.",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1541824,no,
99,Integrated Product Policy and distributed supplier structures: SME and sound LCA data in conflict,"The sustainable development of our societies is one of the priorities of the European Commission. Through its new Integrated Product Policy (IPP), the European Commission is developing a series of measures that influence the supply and demand of environmentally sound products. Some IPP tools are based on product and process self-declarations, while others require the performance of a Life-Cycle Assessment (LCA). Life-Cycle Inventory (LCI) data availability is the fundamental premise in order to be able to perform an LCA. In this paper, the work is to investigate the diffusion of required LCA data along the supplier chain with the aim of identifying strategies to increase the awareness of Small and Medium Enterprises (SMEs) in respect to LCA, to suggest methodologies to facilitate the collection of sound LCI data and to test available low-cost software tools to support LCA, with particular reference to the production phase is reported",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1619261,no,
100,Plug and play testbed to enable responsive space missions,"There exists a growing need in the DOD for a tactical or responsive space asset to support real-time battlefield intelligence, surveillance, and reconnaissance. The desired attributes include being: 1. responsive /sub e/ployable in days; 2. affordable - expendable tactical resources at a cost comparable to other tactical systems; 3. employable - assets must support the joint force commander (JFC); 4. integrated space/air/terrestrial system-of-systems - full network connectivity, bandwidth on demand, and augment other assets. To the warfighter, a responsive space asset would provide the capability to respond to unanticipated military needs in days, providing flexibility of response to rapidly field tailored payloads and coverage. This capability could also provide rapid reconstitution after a loss from attack or failure and counteract enemy adaptation, through denial or deception, to existing space capabilities. Most importantly the short deployment times and low cost would provide the United States a means for efficiently using the versatility, and relative safety of space to provide real-time support to the war fighter. To be responsive the space element must possess a modular design supporting ""plug and play"" (PnP) architecture, leveraging commercial parts and standards. Lending itself to a lean production and integration environment again utilizing standard interfaces and taking advantage of pre-qualified inventoried subsystems. Rapid deployment of these elements will make use of ""canned"" mission planning tools, tailored orbits for a given theater, built-in health and status monitoring, and autonomous test and checkout software and operations. The two emerging responsive mission objectives include space control and tailored, tactical intelligence, surveillance, reconnaissance (ISR). Space control involves a situational awareness to sense threats against, and provide protection for, US space assets. The tailored, tactical missions offer high tempo ISR operations such as target characterization and emitter location in theater, perform real-time blue force tracking, and provide gap-filler, specialized communications support. The challenge is to develop and qualify the satellite technologies and rapid integration and test processes to support an operational responsive system in the next five years. Under an Air Force Research Laboratory SBIR program, MicroSat Systems is developing a PnP testbed to enable an operational responsive capability through development and ground validation of the various elements. Those elements include the mission definition and CONOPS specification processes, space segment, and the operational prioritization, tasking, processing, exploitation, and dissemination (PTPED) process/infrastructure. Specific to providing an end-to-end mission simulation, the testbed should be equipped with the modeling and simulation tools to develop tactical satellite CONOPS and provide the warfighter with a front end tool for training. To validate utility to the end-user the testbed must be equipped with the capability to simulate the data processing and dissemination infrastructure envisioned to provide the battlefield commander with real-time data. The space segment of the testbed should consist of the hardware and software elements required to simulate the operations of a fully functional satellite system. The approach to developing a responsive mission testbed includes defining requirements, hardware/software architecture, technology development roadmap, starting with a core capability, and incrementally integrating and validating the developing components and processes as they emerge.",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1559345,no,
101,Prioritize code for testing to improve code coverage of complex software,"Code prioritization for testing promises to achieve the maximum testing coverage with the least cost. This paper presents an innovative method to provide hints on which part of code should be tested first to achieve best code coverage. This method claims two major contributions. First it takes into account a ""global view"" of the execution of a program being tested, by considering the impact of calling relationship among methods/functions of complex software. It then relaxes the ""guaranteed"" condition of traditional dominator analysis to be ""at least"" relationship among dominating nodes, which makes dominator calculation much simpler without losing its accuracy. It also then expands this modified dominator analysis to include global impact of code coverage, i.e. the coverage of the entire software other than just the current function. We implemented two versions of code prioritization methods, one based on original dominator analysis and the other on relaxed dominator analysis with global view. Our comparison study shows that the latter is consistently better in terms of identifying code for testing to increase code coverage",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1544723,yes,
102,System test case prioritization of new and regression test cases,"Test case prioritization techniques have been shown to be beneficial for improving regression-testing activities. With prioritization, the rate of fault detection is improved, thus allowing testers to detect faults earlier in the system-testing phase. Most of the prioritization techniques to date have been code coverage-based. These techniques may treat all faults equally. We build upon prior test case prioritization research with two main goals: (1) to improve user-perceived software quality in a cost effective way by considering potential defect severity and (2) to improve the rate of detection of severe faults during system-level testing of new code and regression testing of existing code. We present a value-driven approach to system-level test case prioritization called the prioritization of requirements for test (PORT). PORT prioritizes system test cases based upon four factors: requirements volatility, customer priority, implementation complexity, and fault proneness of the requirements. We conducted a PORT case study on four projects developed by students in advanced graduate software testing class. Our results show that PORT prioritization at the system level improves the rate of detection of severe faults. Additionally, customer priority was shown to be one of the most important prioritization factors contributing to the improved rate of fault detection.",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1541815,yes,
103,"Systematic incremental development of agent systems, using Prometheus","This paper presents a mechanism for dividing an agent oriented application into the three IEEE defined scoping levels of essential, conditional and optional. This mechanism is applied after the initial system specification, and is then used to direct incremental development with three separate releases. The scoping described can be applied at any stage of a project, in order to guide consistent scoping back if such is needed. The three levels of scoping that are used are consistent with the approach used in many companies. The approach to scoping requires that scenarios are prioritised manually on a five point scale. All other aspects are then prioritised automatically, based on this information. The approach used allows a developer to indicate what size partitions - based on number of scenarios - are required for each scoping level. The mechanisms are applied to the Prometheus development methodology and are integrated into the Prometheus design tool (PDT).",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1579165,no,
104,Test factoring: focusing test suites for the task at hand,"Frequent execution of a test suite during software maintenance can catch regression errors early, indicate whether progress is being made, and improve productivity. However, if the test suite takes a long time to produce feedback, the developer is slowed down, and the benefit of frequent testing is reduced. After a program is edited, ideally, only changed code would be tested. Any time spent executing previously tested, unchanged parts of the code is wasted. For a large test suite containing many small unit tests, test selection and prioritization can be effective. Test selection runs only those tests that are possibly affected by the most recent change, and test prioritization can run first the tests that are most likely to reveal a recently-introduced error.",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1553636,no,
105,Test prioritization using system models,"During regression testing, a modified system is retested using the existing test suite. Because the size of the test suite may be very large, testers are interested in detecting faults in the system as early as possible during the retesting process. Test prioritization tries to order test cases for execution so the chances of early detection of faults during retesting are increased. The existing prioritization methods are based on the code of the system. System modeling is a widely used technique to model state-based systems. In this paper, we present methods of test prioritization based on state-based models after changes to the model and the system. The model is executed for the test suite and information about model execution is used to prioritize tests. Execution of the model is inexpensive as compared to execution of the system; therefore the overhead associated with test prioritization is relatively small. In addition, we present an analytical framework for evaluation of test prioritization methods. This framework may reduce the cost of evaluation as compared to the existing evaluation framework that is based on experimentation (observation). We have performed an experimental study in which we compared different test prioritization methods. The results of the experimental study suggest that system models may improve the effectiveness of test prioritization with respect to early fault detection.",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510150,yes,
106,Using occurrence properties of defect report data to improve requirements,"Defect reports generated for faults found during testing provide a rich source of information regarding problematic phrases used in requirements documents. These reports indicate that faults often derive from instances of ambiguous, incorrect or otherwise deficient language. In this paper, we report on a method combining elements of linguistic theory and information retrieval to guide the discovery of problematic phrases throughout a requirements specification, using defect reports and correction requests generated during testing to seed our detection process. We found that phrases known from these materials to be problematic have occurrence properties in requirements documents that both allow the direction of resources to prioritize their correction, and generate insights characterizing more general locations of difficulty within the requirements. Our findings lead to some recommendations for more efficiently and effectively managing certain natural language issues in the creation and maintenance of requirements specifications.",2005,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1531046,no,
107,A Dynamic Partitioning Approach for GUI Testing,"Previous works on GUI testing are mainly concerned with how to define or generate GUI test cases. The issue of how to employ generated GUI test cases or primitive actions is seldom discussed. In this paper we propose a dynamic partitioning approach for GUI testing to address the issue. In this approach, the given GUI primitive actions are dynamically partitioned into two disjoint classes: one comprising prioritized primitive actions and the other comprising non-prioritized ones. The testing process is divided into two stages and contains two feedback loops. The first stage prioritizes primitive actions and the second stage selects and performs prioritized primitive actions. The first feedback loop is local and occurs in the second stage, which adjusts the memberships of primitive actions after they are performed. The second feedback loop is global and occurs between the first and second stages. It switches GUI testing from the second stage to the first stage upon no prioritized primitive actions are available. Two testing experiments with real GUI applications show that the proposed dynamic partitioning approach can really work in practice and may significantly outperform the random testing approach in the sense that the dynamic partitioning approach uses fewer primitive actions to achieve given testing goals and behaves more stable. The dynamic partitioning approach adopts explicit feedback mechanisms and contributes to the emerging area of software cybernetics that explores the interplay between software and control",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4020171,no,
108,A Feature-Oriented Requirements Tracing Method: A Study of Cost-benefit Analysis,"Establishing and maintaining traceability links places a big burden since complex systems have especially yield an enormous number of various artifacts although traceability links is useful for requirements change impact analysis, requirements conflict analysis, and requirements consistency checking. Hence, we propose a feature-oriented requirements tracing method including value consideration and intermediate catalysis. To achieve our goal in this paper, we present (1) a meta-model of feature-oriented requirements tracing, (2) a featureoriented requirement tracing process overview, and (3) cost-benefits analysis. The meta-model is a formalization of feature-oriented requirement tracing using UML notation. The feature-oriented requirement tracing process consists of requirements definition, feature modeling, feature prioritization, requirements linking, and traceability links evaluation. We also carry out cost-benefit analysis through a case study to demonstrate the feasibility of our approach.",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4021275,no,
109,A hardware implementation of layer 2 MPLS,"This paper presents a hardware architecture for layer 2 Multi Protocol Label Switching (MPLS). MPLS is a protocol framework used primarily to prioritize internet traffic and improve bandwidth utilization. Furthermore it increases the performance of internet applications and overall efficiency. However, most existing MPLS solutions are entirely software based which decreases performance. MPLS performance can be enhanced by executing core tasks in hardware while allowing other tasks to be executed in software to guard against performance degradation. This paper proposes a hardware design of MPLS on an FPGA for increased performance and efficiency.",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1581247,no,
110,An Add-On for Managing Behaviours with Priority in JADE,"In this article, two new implementations for behaviours in JADE are presented. These new behaviours, while being able to reproduce the functioning of the old JADE's behaviours, allow the user to define priorities. This fact is of vital importance for several multiagent applications. Finally, a test was developed to show that the performance of the new behaviours is similar to the original ones.",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4053000,no,
111,An Agent-Based E-Learning Assessing and Instructing System,"The research work on e-learning has become very important field in the education. Many demands for instructing strategies in the adaptive learning have turn out. Base on these instructing strategies, the learners could reduce their blindness in the learning process. This paper proposes a method to build a Bayesian networks model in order to assess the learner's knowledge level and instruct the learner. This e-learning assessing and instructing system is designed and implemented based on multi-agent systems (ELAIS). In this system, the knowledge cognitive level, the learning priorities and weakness of a learner could be analyzed and assessed through the tracking information. Then the corresponding instruction will give to the learner in order to improve the learner's learning efficiency. The parameters assessment is achieved using EM algorithm and the assessment results in this system reveal the pretty accuracy to the real testing situation",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4019230,no,
112,Applying CMMI and Strategy to ATE Development,"This paper provides a viewpoint of the capability maturity model integration (CMMI<sup>SM</sup> ) from the perspective of automated test equipment (ATE) development and test engineering. ATE development is a specialized segment of product development and shares many of the same issues. Requirements for the test equipment are very dependent on continually evolving product characteristics. Even with the best planning, lead times for ATE development are typically eroded by late changes to product requirements and designs, and eventually the critical path leads right through test! Without a solid process foundation, chaos ensues. The CMMI process models provide a framework for the integration of best practices in many disciplines. Portions of the systems engineering, software engineering, Integrated Product and Process Development and Supplier Sourcing models all offer important perspectives which affect ATE developers. This paper focuses on the CMMI processes and best practices which yield the greatest impact to test organizations and groups that provide ATE. The overall Test Strategy should help prioritize the process areas which deserve the most attention. Mature ATE organizations use a Balanced Scorecard approach to provide alignment with corporate and program level goals. Metrics monitor their progress against their corporate goals. At the program level, they apply a risk- driven approach to selectively apply resources that achieve the highest ROI for test dollars. From this business-oriented vantage point, organizations are likely to see increased efficiencies that will decrease overall system development costs by streamlining the testing component of their budgets.",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4062482,no,
113,DDP: a tool for life-cycle risk management,"At JPL we have developed and implemented a process for achieving life-cycle risk management. This process has been embodied in a software tool and is called defect detection and prevention (DDP). The DDP process can be succinctly stated as: determine where we want to be, what could get in the way and how we will get there. The ""determine where we want to be"" is captured as trees of requirements and the ""what could get in the way"" is captured as trees of potential failure modes. Scoring the impacts of these failure modes on the requirements results in a prioritized set of failure modes. The user then selects from a set of preventative measures, analyses, process controls and tests (PACTs) each of which has an effectiveness versus the various failure modes. It is the goal of the DDP process to optimally select the subset of the PACTs which minimizes the residual risk subject to the project resource constraints. The DDP process is intended to facilitate risk management over the entire project life cycle beginning with architectural and advanced technology decisions all the way through operation. As the project design, technology content, and implementation approach matures, the requirements and failure mode trees are elaborated upon to accommodate the additional information. Thus, the DDP process is a systematic, continuous, top-down approach to managing risk. Implementation of the DDP process requires a critical mass of expertise (usually the project team and a few specialists) and captures both their engineering judgement as well as available quantitative data. This additional data may result from models, layouts, prototype testing, other focused risk evaluations and institutional experiences. The DDP process also identifies areas where additional information would be advantageous, thus allowing a project to target critical areas of risk or risk uncertainty. This also allows the project to identify those areas which would benefit the most from application of other quantitative tools and methods (e.g. Monte Carlo simulations, FMECAs, fault trees). The software tool supports the DDP process by providing guidance for implementing the process steps, graphical visualizations of the various trees, their interrelationships and the current risk landscape. The tool is capable of supporting on-the-fly knowledge elicitation as well as integrating off-line deliberations. There are a variety of available outputs including graphs, trees and reports as well as clear identification of the driving requirements, ""tall-pole"" residual risks and the PACTs which have been selected and agreed upon. The DDP process has been applied at various levels of assembly including the system and subsystem levels, as well as down to the component level. Recently, significant benefits have been realized from application to advanced technologies, where the focus has been on increasing the infusion rates of these technologies by identification and mitigation of risks prior to delivery to a project",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1662004,no,
114,"Expert System for Quality Cost Planning, Monitoring and Control","On the market, there are some commercial available software tools for quality cost management. However, these tools do not incorporate specialized agents for handling complex tasks related to the current needs in quality cost planning, like interpretation of the results over a horizon of time and automatic generation of reliable guidelines to prioritize resources in order to improve the quality of the business processes. This paper is going to introduce the results of some researches performed by the authors in designing and developing an expert system for comprehensive monitoring, controlling and planning of quality costs within business processes. Results are already successful implemented in a large enterprise from chemical industry",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4022922,no,
115,How International Standards Such as ATML and IEEE 1641 STD can Make the Realisation of an Open System Architecture on a Common Test Platform a Reality,"A perspective on how the DoD and MoD are integrating open standards into their ATS frameworks and policy in the search for a common test platform architecture solution for use on all test platforms. The paper examines the two approaches being taken and draws on their commonality to propose how open standards can help meet both their aims and circumstances. Benefits such as TPS interoperability, re-host and re-use are examined and contrasted for open systems versus common architecture to identify the practical implication for real systems. The life cycle cost of support for the system is identified and the trade-off in cost between fast optimal TPSs and fully interoperable TPSs is considered. The paper goes on to show the difference between using information models utilizing a development process versus the use of run time interfaces and how they can lead to different solutions to the same basic problem but with different peripheral benefits. In conclusion an approach to maximize benefit between the two framework groups is considered whilst maintaining individual priorities.",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4062469,no,
116,Improving Testing Efficiency using Cumulative Test Analysis,"It can be impossible to thoroughly test complex software projects with a large library of tests to be run in many environments and configurations. The cumulative test analysis (CTA) technique described reduces the time to find defects by prioritising and minimising the testing. Tests are chosen to target the product areas having the highest risk of defects. Test effectiveness, test code coverage, product code changes and changes to dependencies are monitored and analysed to prioritise the testing. Test results from build to build are accumulated. Build reports clearly identify areas at risk, test results, and the tests that must be run. Experiences with a prototype tool are discussed and conclusions drawn from the use of CTA show that defects are found sooner, more time is available for writing new tests and the focus of test execution moves towards product quality instead of simply test results",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1691682,no,
117,On the Use of Mutation Faults in Empirical Assessments of Test Case Prioritization Techniques,"Regression testing is an important activity in the software life cycle, but it can also be very expensive. To reduce the cost of regression testing, software testers may prioritize their test cases so that those which are more important, by some measure, are run earlier in the regression testing process. One potential goal of test case prioritization techniques is to increase a test suite's rate of fault detection (how quickly, in a run of its test cases, that test suite can detect faults). Previous work has shown that prioritization can improve a test suite's rate of fault detection, but the assessment of prioritization techniques has been limited primarily to hand-seeded faults, largely due to the belief that such faults are more realistic than automatically generated (mutation) faults. A recent empirical study, however, suggests that mutation faults can be representative of real faults and that the use of hand-seeded faults can be problematic for the validity of empirical results focusing on fault detection. We have therefore designed and performed two controlled experiments assessing the ability of prioritization techniques to improve the rate of fault detection of test case prioritization techniques, measured relative to mutation faults. Our results show that prioritization can be effective relative to the faults considered, and they expose ways in which that effectiveness can vary with characteristics of faults and test suites. More importantly, a comparison of our results with those collected using hand-seeded faults reveals several implications for researchers performing empirical studies of test case prioritization techniques in particular and testing techniques in general",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1707670,yes,
118,Optimizing the selection of representative configurations in verification of evolving product lines of distributed embedded systems,"Electronics and computer science play a more and more prominent role in automotive technology. In the future the prevalence of those new technologies and the customers' demand for individuality leads to tremendously large configuration spaces of vehicle control systems. To cope with the resulting complexity in verification, new strategies need to be explored. One likely future challenge is to determine a set of vehicle configurations, such that the successful verification of this small set implies the correctness of the entire product family. This paper presents a method to address this task, based on exploiting communalities in architecture and requirements. We introduce efficient algorithms with provable quality guarantees for the optimization problems of choosing the minimum set of configurations necessary to verify all possible configurations and choosing the best k configurations to maximize the verification coverage of the entire product family. We discuss extensions of our method which allow requirement priorities and the consideration of configuration costs, and present a technique for automatically determining communalities in architecture and requirements which can be exploited by our optimization methods. We demonstrate the effectiveness of our method on an indicator light system product family. In this example a configuration reduction by 60% can be achieved",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1691579,no,
119,Prioritizing Software Inspection Results using Static Profiling,"Static software checking tools are useful as an additional automated software inspection step that can easily be integrated in the development cycle and assist in creating secure, reliable and high quality code. However, an often quoted disadvantage of these tools is that they generate an overly large number of warnings, including many false positives due to the approximate analysis techniques. This information overload effectively limits their usefulness. In this paper we present ELAN, a technique that helps the user prioritize the information generated by a software inspection tool, based on a demand-driven computation of the likelihood that execution reaches the locations for which warnings are reported. This analysis is orthogonal to other prioritization techniques known from literature, such as severity levels and statistical analysis to reduce false positives. We evaluate feasibility of our technique using a number of case studies and assess the quality of our predictions by comparing them to actual values obtained by dynamic profiling.",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4026864,no,
120,Prognostics usefulness criteria,"Prognostics and health management (PHM) can provide remarkable insight for maintenance management of large systems, but must be implemented with a healthy respect for the end user and a practical view of the hardware and software capabilities. The F-35 Joint Strike Fighter (JSF) program is implementing a comprehensive PHM system to maximize the supportability of the air system. The prognostic algorithms must have a defined minimum capability to aid implementation and verification. However, the complexity of the air system precludes creating exact requirements for remaining useful life and confidence. Instead, ""usefulness criteria"" are created to link the user need with the minimum capability of the algorithm. The usefulness criteria are a list of goals related to aircraft supportability which can be used to define the minimum acceptable time to maintenance indication for the prognostic algorithm. The goals in the usefulness criteria were applied to each prognostic algorithm in the F-35 PHM system. When assigned, these usefulness criteria provide a means to measure the improved performance of the aircraft and fleet maintenance as well as prioritize the implementation of the prognostic algorithms. The development and implementation of the algorithms in relation to these usefulness criteria are still in process, but it is expected that most algorithms exceeds the criteria. Those which do not meet the criteria are re-evaluated with a trade study to determine if further efforts in hardware and software development are warranted. This process of usefulness criteria development and application can be rigorously applied to the development of any PHM system. This paper covers the development of the usefulness criteria for the F-35 program and the implementation results to date",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1656123,no,
121,"Recorders, Reasoners and Artificial Intelligence - Integrated Diagnostics on Military Transport Aircraft","A research group at Boeing has developed a prototype for an integrated diagnostic system to optimize maintenance on military transport aircraft by decreasing maintenance costs and increasing aircraft availability. The integrated diagnostic system comprises an on-board recorder, and a ground-based reasoner that analyzes the recorded data, to optimize maintenance. The functions of the ground-based reasoner (GBR) include identification of root-cause, filtering of false alarms, and prioritization of maintenance actions. The technologies used include expert systems/fast state recognition methods, data mining technologies and Bayesian analyses. The ground-based reasoner provides an open plug-n-play software framework for incorporating these technologies into a software tool, for field maintenance. The tool has a simple, intuitive graphic user interface that is designed to help the end-user, the maintenance technician, with everyday maintenance tasks. The integrated diagnostic system prototype is currently undergoing testing on pre-delivery test flights for the C-17 military transport, at a Boeing facility, and initial results in applying the system to the aerial delivery subsystem and the hydraulic subsystem are discussed",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1656074,no,
122,Search Based Approaches to Component Selection and Prioritization for the Next Release Problem,This paper addresses the problem of determining the next set of releases in the course of software evolution. It formulates both ranking and selection of candidate software components as a series of feature subset selection problems to which search based software engineering can be applied. The approach is automated using greedy and simulated annealing algorithms and evaluated using a set of software components from the component base of a large telecommunications organization. The results are compared to those obtained by a panel of (human) experts. The results show that the two automated approaches convincingly outperform the expert judgment approach,2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4021335,no,
123,Test Case Prioritization Using Relevant Slices,"Software testing and retesting occurs continuously during the software development lifecycle to detect errors as early as possible. The sizes of test suites grow as software evolves. Due to resource constraints, it is important to prioritize the execution of test cases so as to increase chances of early detection of faults. Prior techniques for test case prioritization are based on the total number of coverage requirements exercised by the test cases. In this paper, we present a new approach to prioritize test cases based on the coverage requirements present in the relevant slices of the outputs of test cases. We present experimental results comparing the effectiveness of our prioritization approach with that of existing techniques that only account for total requirement coverage, in terms of ability to achieve high rate of fault detection. Our results present interesting insights into the effectiveness of using relevant slices for test case prioritization",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4020103,yes,
124,The Incremental Evolution of Attack Agents in Xpilot,"In the research presented in this paper, we use incremental evolution to learn multifaceted neural network (NN) controllers for agents operating in the space game Xpilot. Behavioral components specific to the accomplishment of specific tasks, such as bullet-dodging, shooting, and closing on an enemy, are learned in the first increment. These behavioral components are used in the second increment to evolve a NN that prioritizes the output of a two-layer NN depending on that agent's current situation.",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1688415,no,
125,Towards Interactive Fault Localization Using Test Information,"Finding the location of a fault is a central task of debugging. Typically, a developer employs an interactive process for fault localization. To accelerate this task, several approaches have been proposed to automate fault localization. In practice, testing-based fault localization (TBFL), which uses test information to locate faults, has become a research focus. However, experimental results reported in the literature showed that current automation of fault localization can only serve as a means to confirming the search space and prioritizing search sequences, not a substitute of the interactive fault localization process. In this paper, we propose an approach based on test information to support the entire interactive fault localization process. During this process, the information gathered from previous interaction steps can be used to provide the ranking of suspicious statements for the current interaction step. As a feasibility study of our approach, we performed an experiment on applying our approach together with some other TBFL approaches on the Siemens programs, which have been used in the literature. Our experimental results show the effectiveness of our approach.",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4137428,no,
126,Using the Case-Based Ranking Methodology for Test Case Prioritization,"The test case execution order affects the time at which the objectives of testing are met. If the objective is fault detection, an inappropriate execution order might reveal most faults late, thus delaying the bug fixing activity and eventually the delivery of the software. Prioritizing the test cases so as to optimize the achievement of the testing goal has potentially a positive impact on the testing costs, especially when the test execution time is long. Test engineers often possess relevant knowledge about the relative priority of the test cases. However, this knowledge can be hardly expressed in the form of a global ranking or scoring. In this paper, we propose a test case prioritization technique that takes advantage of user knowledge through a machine learning algorithm, case-based ranking (CBR). CBR elicits just relative priority information from the user, in the form of pairwise test case comparisons. User input is integrated with multiple prioritization indexes, in an iterative process that successively refines the test case ordering. Preliminary results on a case study indicate that CBR overcomes previous approaches and, for moderate suite size, gets very close to the optimal solution",2006,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4021329,yes,
127,A histogram-matching approach to the evolution of bin-packing strategies,"We present a novel algorithm for the one- dimension offline bin packing problem with discrete item sizes based on the notion of matching the item-size histogram with the bin-gap histogram. The approach is controlled by a constructive heuristic function which decides how to prioritise items in order to minimise the difference between histograms. We evolve such a function using a form of linear register-based genetic programming system. We test our evolved heuristics and compare them with hand-designed ones, including the well- known best fit decreasing heuristic. The evolved heuristics are human-competitive, generally being able to outperform high- performance human-designed heuristics.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4424926,no,
128,A model to predict anti-regressive effort in Open Source Software,"Accumulated changes on a software system are not uniformly distributed: some elements are changed more often than others. For optimal impact, the limited time and effort for complexity control, called anti-regressive work, should be applied to the elements of the system which are frequently changed and are complex. Based on this, we propose a maintenance guidance model (MGM) which is tested against real-world data. MGM takes into account several dimensions of complexity: size, structural complexity and coupling. Results show that maintainers of the eight open source systems studied tend, in general, to prioritize their anti-regressive work in line with the predictions given by our MGM, even though, divergences also exist. MGM offers a history-based alternative to existing approaches to the identification of elements for anti-regressive work, most of which use static code characteristics only.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362632,no,
129,A Multi-Agent Solution to Distribution Systems Restoration,"The goal to provide faster and faster restoration after a fault is pushing the technical envelope related to new algorithms. While many approaches use centralized strategies, the concept of multi-agent systems (MAS) is creating a new option related to distributed analyses for restoration. This paper provides details on a MAS that restores a power system after a fault. The development of agents and behaviors of the agents are described, including communication of agents. The MAS is tested on two test systems and facilitates both full and partial restoration, including load prioritization and shedding.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4282055,no,
130,A Multipurpose Code Coverage Tool for Java,"Most test coverage analyzers help in evaluating the effectiveness of testing by providing data on statement and branch coverage achieved during testing. If made available, the coverage information can be very useful for many other related activities, like, regression testing, test case prioritization, test-suite augmentation, test-suite minimization, etc. In this paper, we present a Java-based tool JavaCodeCoverage for test coverage reporting. It supports testing and related activities by recording the test coverage for various code-elements and updating the coverage information when the code being tested is modified. The tool maintains the test coverage information for a set of test cases on individual as well as test suite basis and provides effective visualization for the same. Open source database support of the tool makes it very useful for software testing research",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4076910,no,
131,A Novel Approach of Prioritizing Use Case Scenarios,"Modern softwares are very large and complex. As the size and complexity of software increases, software developers feel an urgent need for a better management of different activities during the course of software development. In this paper, we present an approach of use case scenario prioritization suitable for project planning at an early phase of the software development. We consider only use case model in our work. For prioritization, we focus on how critical a scenario path is, which essentially depends on density of overlapping of sub path of a scenario path with other scenario path(s) of a use case. Our proposed approach provides an analytical solution on use case scenario prioritization and is very much effective in project management related activities as substantiated by our experimental results.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4425898,yes,
132,A process framework for customising software quality models,The quality objective of many software organisations is to deliver software products that meet and or exceed customer expectations. The key to achieving this is to capture these expectations at the beginning of the project by clearly defining all quality requirements. The characteristics particularly defined in ISO/IEC 9126-1 (2001) provide the framework for specifying quality requirements. The ISO/IEC 9126-1 quality model is intended to be applicable to any type of software product or intermediate product. Before application this model needs to be tailored to a specific software and specific need. Since these characteristics cannot be directly measured this makes it difficult to directly prioritise and choose the most relevant characteristics and sub-characteristics. Hence a process framework that will link these characteristics and sub- characteristics to user needs is required. This will in turn help customise software quality models like ISO/IEC 9126-1 (2001) and other general software quality models. A process framework for customising software quality models is proposed in the text and it is further shown how this framework was applied in a real working environment in an attempt to quantitatively validate it. The results collected in the study showed that the framework could be used reliably in customising a generic software quality model at characteristic level only. The deviations at sub-characteristic level were due to unclear questions in the generated Generic Quality Questionnaire that resulted in misunderstandings. And the metrics used to create these questions were not fully tested for validity and reliability due to time constraints. Enhancements are discussed in the study and it is further shown how reliability can also be achieved at sub-characteristic level.,2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4401495,no,
133,A Visualization Framework for Web Service Discovery and Selection Based on Quality of Service,"The visualization of Web service execution process is an emerging research in service-oriented computing (SOC) area. This paper presents a practical visualization framework in putting service discovery and selection process based on quality of service (QoS) attributes into a visual context. The proposed practical architecture serves as a foundation for designing the novel GUIs for different users. By considering the preferences and priorities for service consumers and service providers, we adopt different application UI design criteria and design patterns which tailored to service-based visualization design. Based on that, evaluation is carried out to test the usability, effectiveness and acceptability of the proposed visualization framework.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4414476,no,
134,Applying Interface-Contract Mutation in Regression Testing of Component-Based Software,"Regression testing, which plays an important role in software maintenance, usually relies on test adequacy criteria to select and prioritize test cases. However, with the wide use and reuse of black-box components, such as reusable class libraries and COTS components, it is challenging to establish test adequacy criteria for testing software systems built on components whose source code is not available. Without source code or detailed documents, the misunderstanding between the system integrators and component providers has become a main factor of causing faults in component-based software. In this paper, we apply mutation on interface contracts, which can describe the rights and obligations between component users and providers, to simulate the faults that may occur in this way of software development. The mutation adequacy score for killing the mutants of interface contracts can serve as a test adequacy criterion. We performed an experimental study on three subject systems to evaluate the proposed approach together with four other existing criteria. The experimental results show that our adequacy criterion is helpful for both selecting good-quality test cases and scheduling test cases in an order of exposing faults quickly in regression testing of component-based software.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362630,yes,
135,Combinatorial Interaction Regression Testing: A Study of Test Case Generation and Prioritization,"Regression testing is an expensive part of the software maintenance process. Effective regression testing techniques select and order (or prioritize) test cases between successive releases of a program. However, selection and prioritization are dependent on the quality of the initial test suite. An effective and cost efficient test generation technique is combinatorial interaction testing, CIT, which systematically samples all t-way combinations of input parameters. Research on CIT, to date, has focused on single version software systems. There has been little work that empirically assesses the use of CIT test generation as the basis for selection or prioritization. In this paper we examine the effectiveness of CIT across multiple versions of two software subjects. Our results show that CIT performs well in finding seeded faults when compared with an exhaustive test set. We examine several CIT prioritization techniques and compare them with a re-generation/prioritization technique. We find that prioritized and re-generated/prioritized CIT test suites may find faults earlier than unordered CIT test suites, although the re-generated/prioritized test suites sometimes exhibit decreased fault detection.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362638,yes,
136,Compatibility and Regression Testing of COTS-Component-Based Software,"Software engineers frequently update COTS components integrated in component-based systems, and can often chose among many candidates produced by different vendors. This paper tackles both the problem of quickly identifying components that are syntactically compatible with the interface specifications, but badly integrate in target systems, and the problem of automatically generating regression test suites. The technique proposed in this paper to automatically generate compatibility and prioritized test suites is based on behavioral models that represent component interactions, and are automatically generated while executing the original test suites on previous versions of target systems.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4222571,yes,
137,Control unit for a laboratory motor test bench for monitoring and controlling PMSM and induction motors,"The work presents a state-of-art control unit for pulse width modulated inverter-fed AC motors. The unit is suitable for a wide range of voltage source inverters with frequencies ranging from 1 KHz to up to 100 KHz. The hardware is characterized by a powerful floating point DSP, FPGA unit, asynchronous serial and IEEE 1394 communication interface, and 12 channels Analog/Digital interface with sample and conversion times together equaling 250 ns. The control software is managed by a specially designed real-time multitasking operating system. The operating system guarantees less than 300 ns time duration when jumping from one task to another upon internal or external event. The operating system can be adapted easily for arbitrary number of tasks with various prioritization levels and triggering events, and therefore suitable for interfacing hardware in the loop (HIL) simulation environments. The on-line interaction between the user and the running control software is implemented by a specially designed IEEE1394 driver for Windows XP and a graphical user interface (GUI). This allows graphical and numerical monitoring of software variables and their modification at will.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4417431,no,
138,Data Mining Static Code Attributes to Learn Defect Predictors,"The value of using static code attributes to learn defect predictors has been widely debated. Prior work has explored issues like the merits of ""McCabes versus Halstead versus lines of code counts"" for generating defect predictors. We show here that such debates are irrelevant since how the attributes are used to build predictors is much more important than which particular attributes are used. Also, contrary to prior pessimism, we show that such defect predictors are demonstrably useful and, on the data studied here, yield predictors with a mean probability of detection of 71 percent and mean false alarms rates of 25 percent. These predictors would be useful for prioritizing a resource-bound exploration of code that has yet to be inspected",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4027145,no,
139,Effective Fault Localization using Code Coverage,"Localizing a bug in a program can be a complex and time- consuming process. In this paper we propose a code coverage-based fault localization method to prioritize suspicious code in terms of its likelihood of containing program bugs. Code with a higher risk should be examined before that with a lower risk, as the former is more suspicious (i.e., more likely to contain program bugs) than the latter. We also answer a very important question: how can each additional test case that executes the program successfully help locate program bugs? We propose that with respect to a piece of code, the aid introduced by the first successful test that executes it in computing its likelihood of containing a bug is larger than or equal to that of the second successful test that executes it, which is larger than or equal to that of the third successful test that executes it, etc. A tool, chiDebug, was implemented to automate the computation of the risk of the code and the subsequent prioritization of suspicious code for locating program bugs. A case study using the Siemens suite was also conducted. Data collected from our study support the proposal described above. They also indicate that our method (in particular Heuristics III (c), (d), and (e)) can effectively reduce the search domain for locating program bugs.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4291037,no,
140,Enhancing the Efficiency of Regression Testing through Intelligent Agents,"Software testing is indispensable for all software development. As all mature engineering disciplines need to have systematic testing methodologies, software testing is a very important subject of software engineering. In software development practice, testing accounts for as much as 50% of total development efforts. Testing can be manual, automated, or a combination of both.Manual testing is the process of executing the application and manually interacting with the application, specifying inputs and observing outputs. Manually testing the software is inefficient and costly. It is imperative to reduce the cost and improve the effectiveness of software testing by automating the testing process, which contains many testing related activities using various techniques and methods. In order to automate the process, we have to have some ways to generate oracles from the specification, and generate test cases to test the target software against the oracles to decide their correctness. Today we still don't have a full-scale system that has achieved this goal. In general, significant amount of human intervention is still needed in testing. The degree of automation remains at the automated test script level. This paper therefore provides a timely summary and enhancement of agent theory in software testing ,which motivates recent efforts in adapting concepts and methodologies for agent oriented software testing to complex system which has not previously done. Agent technologies facilitate the automated software testing by virtue of their high level decomposition, independency and parallel activation[4]. Usage of agent based regression testing reduces the complexity involved in prioritizing the testcases.With the ability of agents to act autonomously, monitoring code changes and generating test cases for the changed version of the code can be done dynamically. Agent-Oriented Software testing (AOST) is a nascent but active field of research . A comprehensive methodology that plays an essential role in Software testing must be robust but easy-to use. Moreover, it should provide a roadmap to guide engineers in creating Agent-based systems. The agent based regression testing(ABRT) proposed here is to offer a definition for encompassing to cover the regression testing phenomena based on agents, yet sufficiently tight that it can rule out complex systems that are clearly not agent based.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4426561,yes,
141,"Increased Mars Rover Autonomy using AI Planning, Scheduling and Execution","This paper presents technology for performing autonomous commanding of a planetary rover. Through the use of AI planning, scheduling and execution techniques, the OASIS autonomous science system provides capabilities for the automated generation of a rover activity plan based on science priorities, the handling of opportunistic science, including new science targets identified by onboard data analysis software, other dynamic decision-making such as modifying the rover activity plan in response to problems or other state and resource changes. We first describe some of the particular challenges this work has begun to address and then describe our system approach. Finally, we report on our experience testing this software with a Mars rover prototype.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4209854,no,
142,Indexing Noncrashing Failures: A Dynamic Program Slicing-Based Approach,"Recent software systems usually feature an automated failure reporting component, with which a huge number of failures are collected from software end-users. With a proper support of failure indexing, which identifies failures due to the same fault, the collected failure data can help developers prioritize failure diagnosis, among other utilities of the failure data. Since crashing failures can be effectively indexed by program crashing venues, current practice has seen great success in prioritizing crashing failures. A recent study of bug characteristics indicates that as excellent memory checking tools are widely adopted, semantic bugs and the resulting noncrashing failures have become dominant. Unfortunately, the problem of how to index non-crashing failures has not been seriously studied before. In previous study, two techniques have been proposed to index noncrashing failures, and they are T-Proximity and R-Proximity. However, as T-Proximity indexes failures by the profile of the entire execution, it is generally not effective because most information in the profile is fault-irrelevant. On the other hand, although R-Proximity is more effective than T-Proximity, it relies on a sufficient number of correct executions that may not be available in practice. In this paper, we propose a dynamic slicing-based approach, which does not require any correct executions, and is comparably effective as R-Proximity. A detailed case study with gzip is reported, which clearly strates the advantages of the proposed approach.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4362658,no,
143,Model Checking Safety-Critical Systems Using Safecharts,"With rapid developments in science and technology, we now see the ubiquitous use of different types of safety-critical systems in our daily lives such as in avionics, consumer electronics, and medical systems. In such systems, unintentional design faults might result in injury or even death to human beings. To make sure that safety-critical systems are really safe, there is a need to verify them formally. However, the verification of such systems is getting more and more difficult because designs are becoming very complex. To cope with high design complexity, currently, model-driven architecture design is becoming a well-accepted trend. However, existing methods of testing and standards conformance are restricted to implementation code, so they do not fit very well with model-based approaches. To bridge this gap, we propose a model-based formal verification technique for safety-critical systems. In this work, the model-checking paradigm is applied to the Safecharts model, which was used for modeling but not yet used for verification. Our contributions listed are as follows: first, the safety constraints in Safecharts are mapped to semantic equivalents in timed automata for verification. Second, the theory for safety constraint verification is proven and implemented in a compositional model checker (that is, the state-graph manipulator (SGM)). Third, prioritized and urgent transitions are implemented in SGM to model the risk semantics in Safecharts. Finally, it is shown that the priority-based approach to mutual exclusion of resource usage in the original Safecharts is unsafe and corresponding solutions are proposed. Application examples show the feasibility and benefits of the proposed model-driven verification of safety-critical systems",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4141241,no,
144,Multi - Layered Best Basis Image Compression,"Software testing is indispensable for all software development. As all mature engineering disciplines need to have systematic testing methodologies, software testing is a very important subject of software engineering. In software development practice, testing accounts for as much as 50% of total development efforts. Testing can be manual, automated, or a combination of both. Manual testing is the process of executing the application and manually interacting with the application, specifying inputs and observing outputs. Manually testing the software is inefficient and costly. It is imperative to reduce the cost and improve the effectiveness of software testing by automating the testing process, which contains many testing related activities using various techniques and methods. In order to automate the process, we have to have some ways to generate oracles from the specification, and generate test cases to test the target software against the oracles to decide their correctness. Today we still don't have a full-scale system that has achieved this goal. In general, significant amount of human intervention is still needed in testing. The degree of automation remains at the automated test script level. This paper therefore provides a timely summary and enhancement of agent theory in software testing ,which motivates recent efforts in adapting concepts and methodologies for agent oriented software testing to complex system which has not previously done. Agent technologies facilitate the automated software testing by virtue of their high level decomposition, independency and parallel activation. Usage of agent based regression testing reduces the complexity involved in prioritizing the test cases.With the ability of agents to act autonomously, monitoring code changes and generating test cases for the changed version of the code can be done dynamically. Agent-oriented software testing (AOST) is a nascent but active field of research . A comprehensive methodology that plays an essential role in software testing must be robust but easy-to use. Moreover, it should provide a roadmap to guide engineers in creating agent-based systems. The agent based regression testing (ABRT) proposed here is to offer a definition for encompassing to cover the regression testing phenomena based on agents, yet sufficiently tight that it can rule out complex systems that are clearly not agent based.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4426345,no,
145,Prioritization of Regression Tests using Singular Value Decomposition with Empirical Change Records,"During development and testing, changes made to a system to repair a detected fault can often inject a new fault into the code base. These injected faults may not be in the same files that were just changed, since the effects of a change in the code base can have ramifications in other parts of the system. We propose a methodology for determining the effect of a change and then prioritizing regression test cases by gathering software change records and analyzing them through singular value decomposition. This methodology generates clusters of files that historically tend to change together. Combining these clusters with test case information yields a matrix that can be multiplied by a vector representing a new system modification to create a prioritized list of test cases. We performed a post hoc case study using this technique with three minor releases of a software product at IBM. We found that our methodology suggested additional regression tests in 50% of test runs and that the highest-priority suggested test found an additional fault 60% of the time.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4402199,yes,
146,Prioritized Constraints with Data Sampling Scores for Automatic Test Data Generation,"Many automatic test data generation approaches use constraint solvers to find data values. One problem with this method is that it cannot generate test data when the constraints are not solvable, either because there is no solution or the constraints are too complex. We propose a constraint prioritization method using data sampling scores to generate valid test data even when a set of constraints is not solvable. Our case study illustrates the effectiveness of this method.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4288019,no,
147,Prioritizing Coverage-Oriented Testing Process - An Adaptive-Learning-Based Approach and Case Study,"This paper proposes a graph-model-based approach to prioritizing the test process. Tests are ranked according to their preference degrees which are determined indirectly, i.e., through classifying the events. To construct the groups of events, unsupervised neural network is trained by adaptive competitive learning algorithm. A case study demonstrates and validates the approach.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4291124,no,
148,Search Algorithms for Regression Test Case Prioritization,"Regression testing is an expensive, but important, process. Unfortunately, there may be insufficient resources to allow for the reexecution of all test cases during regression testing. In this situation, test case prioritization techniques aim to improve the effectiveness of regression testing by ordering the test cases so that the most beneficial are executed first. Previous work on regression test case prioritization has focused on greedy algorithms. However, it is known that these algorithms may produce suboptimal results because they may construct results that denote only local minima within the search space. By contrast, metaheuristic and evolutionary search algorithms aim to avoid such problems. This paper presents results from an empirical study of the application of several greedy, metaheuristic, and evolutionary search algorithms to six programs, ranging from 374 to 11,148 lines of code for three choices of fitness metric. The paper addresses the problems of choice of fitness metric, characterization of landscape modality, and determination of the most suitable search technique to apply. The empirical results replicate previous results concerning greedy algorithms. They shed light on the nature of the regression testing search space, indicating that it is multimodal. The results also show that genetic algorithms perform well, although greedy approaches are surprisingly effective, given the multimodal nature of the landscape",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4123325,yes,
149,Software Fault Localization Based on Testing Requirement and Program Slice,"A heuristic approach is proposed to locate a fault according to the priority. To a given test case wt, fault localization has to be proceeded when its output wrong. Firstly, four assistant test cases, one failed and three successful test cases, are selected out according to the biggest cardinality of Req(wt,t<sub>i</sub>), which stand for the common testing requirements both covered by wt and t<sub>i</sub>. Then, code prioritization methodology is put forward based on program slice technique. Dynamic slice technique is taken for wt and execution slice technique for four assistant test cases. Some dices are constructed with different priority which means the possibility of containing bug and is evaluated according to the occurrences in the selected slices. Thirdly, the key algorithm including two procedures, refining and augmenting, is followed here to fault localization based on priority. In the refining phase, the most suspicious codes am checked step by step; in the augmenting phase, more codes will be gradually considered on the basis of direct data dependency. At last, experimental studies are performed to illustrate the effectiveness of the technique.",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4286423,no,
150,Speaking Truth to Power,"Whenever the author conducts an architectural assessment for software development projects, he endeavors to speak truth to power: those with true power never fear the truth. Sam Guckenheimer has observed that in software code there is truth. Code represents the stark reality of a software development organization's labor. There is also truth to be found in a system's architecture. Every system's architecture is molded by the forces that swirl around it, and the collective concerns of all the stakeholders represent the most dynamic forces shaping a system. The software development organization's unique task is to address all the essential concerns of all the important stakeholders and to ensure that they aren't blindsided by unexpected problems and stakeholders. This is why employing a process that incrementally and iteratively grows a system's architecture through the regular release of testable executables is so important. Such a process lets the software team engage the right stakeholders at the right time and to make the right decisions, neither too early nor too late. In creating a software-intensive system that's both relevant and beautiful, every stakeholder, no matter how close or how far from the code, deserves the truth",2007,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4118643,no,
601,Enhanced Weighted Method for Test Case Prioritization in Regression Testing Using Unique Priority Value,"Regression testing is an integral and expensive part in software testing. To reduce its effort, test case prioritization approaches were proposed. The problem with most of the existing approaches is the random ranking of test cases with equal weight. In this paper, an enhanced weighted method to prioritize the full test suite without using random ranking is presented. In addition, a controlled experiment was executed to evaluate the effectiveness of the proposed method. The results show an improved performance in terms of prioritizing test cases and recording higher APFD values over the original weighted method. In future, a larger experiment would be executed to generalize the results.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7885851,yes,
602,Enhancing Test Case Prioritization in an Industrial Setting with Resource Awareness and Multi-objective Search,"Test case prioritization is an essential part of test execution systems for large organizations developing software systems in the context that their software versions are released very frequently. They must be tested on a variety of compatible hardware with different configurations to ensure correct functioning of a software version on a compatible hardware. In practice, test case execution must not only execute cost-effective test cases in an optimal order, but also optimally allocate required test resources, in order to deliver high quality software releases. To optimize the current test execution system for testing software releases developed for Videoconferencing Systems (VCSs) at Cisco, Norway, in this paper, we propose a resource- aware multi-objective optimization solution with a fitness function defined based on four cost-effectiveness measures. In this context, a set of software releases must be tested on a set of compatible VCS hardware (test resources) by executing a set of cost-effective test cases in an optimal order within a given test cycle constrained by maximum allowed time budget and maximum available test resources. We empirically evaluated seven search algorithms regarding their performance and scalability by comparing with the current practice (random ordering (RO)). The results show that the proposed solution with the best search algorithm (i.e., Random-Weighted Genetic Algorithm) improved the current practice by reducing on average 40.6% of time for test resource allocation and test case execution, improved test resource usage on average by 37.9% and fault detection on average by 60%.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7883302,yes,
603,Experience Report: Automated System Level Regression Test Prioritization Using Multiple Factors,"We propose a new method of determining an effective ordering of regression test cases, and describe its implementation as an automated tool called SuiteBuilder developed by Westermo Research and Development AB. The tool generates an efficient order to run the cases in an existing test suite by using expected or observed test duration and combining priorities of multiple factors associated with test cases, including previous fault detection success, interval since last executed, and modifications to the code tested. The method and tool were developed to address problems in the traditional process of regression testing, such as lack of time to run a complete regression suite, failure to detect bugs in time, and tests that are repeatedly omitted. The tool has been integrated into the existing nightly test framework for Westermo software that runs on large-scale data communication systems. In experimental evaluation of the tool, we found significant improvement in regression testing results. The re-ordered test suites finish within the available time, the majority of fault-detecting test cases are located in the first third of the suite, no important test case is omitted, and the necessity for manual work on the suites is greatly reduced.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7774503,yes,
604,Experience Report: Understanding Cross-Platform App Issues from User Reviews,"App developers publish apps on different platforms, such as Google Play, App Store, and Windows Store, to maximize the user volumes and potential revenues. Due to the different characteristics of the platforms and the different user preference (e.g., Android is more customized than iOS), app testing cases on these three platforms should also be designed differently. Comprehensive app testing can be time-consuming for developers. Therefore, understanding the differences of the app issues on these platforms can facilitate the testing process. In this paper, we propose a novel framework named CrossMiner to analyze the essential app issues and explore whether the app issues exhibit differently on the three platforms. Based on five million user reviews, the framework automatically captures the distributions of seven app issues, i.e., ""battery"", ""crash"", ""memory"", ""network"", ""privacy"", ""spam"", and ""UI"". We discover that the apps for different platforms indeed generate different issue distributions, which can be employed by app developers to schedule and design the testing cases. The verification based on the official user forums also demonstrates the effectiveness of our framework. Furthermore, we also identify that the issues related to ""crash"" and ""network"" are more concerned by users than the other issues on these three platforms. To assist developers in gaining a deep insight on the user issues, we also prioritize the user reviews corresponding to the issues. Overall, we aim at understanding the differences of issues on different platforms and facilitating the testing process for app developers.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7774515,no,
605,Foreword of the Thematic Track Quality Aspects in Agile Methods,"There is no doubt that agile methods have become mainstream and with their increased use unanswered questions start to appear: How do we address cross-cutting concerns when software is developed vertically? Does value prioritization lead to increases in technical debt by promoting feature development over refactoring? Isnƒ??t the reticence to write initial specifications on the premise of change an invitation to unnecessary change? As agile development matures answers, albeit partial, responses start to appear. The recurring themes in this year presentations are not whether agile is good or bad, better or worse,",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7814524,no,
606,Functional stratification of biomarkers selected from microarray data for understanding oral leukoplakia associated carcinogenesis,"In this research paper, we have proposed a three tier conceptual framework AVISAR for the testing of Object Oriented Programs. We have devised the proposed framework into three levels: Requirements Modeling, Test Case Generation and Effort Estimation. At the first level, we have used the Extend relationship of the Use Case to capture the events generated by the Classes during message passing between them through their objects. These events were captured by an Object Instantiator using Event Templates and further given to a Test case scenario generator, which generates the test cases. At the second level, the test cases will be generated based on the event templates that are used for capturing the events generated by the Extend relationship of the Use cases. Further, we have proposed a Genetic Algorithm (GA) for the effective test case prioritization to ensure maximum code coverage. At the third level, effort estimation, we have used the Cyclometric Complexity and Token count to perform the effort estimation for the Software under Test (SUT).",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7915096,no,
607,Guiding Dynamic Symbolic Execution toward Unverified Program Executions,"Most techniques to detect program errors, such as testing, code reviews, and static program analysis, do not fully verify all possible executions of a program. They leave executions unverified when they do not check certain properties, fail to verify properties, or check properties under certain unsound assumptions such as the absence of arithmetic overflow. In this paper, we present a technique to complement partial verification results by automatic test case generation. In contrast to existing work, our technique supports the common case that the verification results are based on unsound assumptions. We annotate programs to reflect which executions have been verified, and under which assumptions. These annotations are then used to guide dynamic symbolic execution toward unverified program executions. Our main technical contribution is a code instrumentation that causes dynamic symbolic execution to abort tests that lead to verified executions, to prune parts of the search space, and to prioritize tests that cover more properties that are not fully verified. We have implemented our technique for the .NET static analyzer Clousot and the dynamic symbolic execution tool Pex. It produces smaller test suites (by up to 19.2%), covers more unverified executions (by up to 7.1%), and reduces testing time (by up to 52.4%) compared to combining Clousot and Pex without our technique.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886899,no,
608,History-Based Dynamic Test Case Prioritization for Requirement Properties in Regression Testing,"Regression testing is an important but extremely costly and time-consuming process. Because of limited resources in practice, test case prioritization focuses on the improvement of testing efficiency. However, traditional test case prioritization techniques emphasize only one-time testing without considering huge historical data generated in regression testing. This paper proposes an approach to prioritizing test cases based on historical data. Requirements are a significant factor in the testing process, the priorities of test cases are initialized based on requirement priorities in our history-based approach, and then are calculated dynamically according to historical data in regression testing. To evaluate our approach, an empirical study on an industrial system is conducted. Experimental results show an improved performance for our proposed method using measurements of Average Percentage of Faults Detected and Fault Detection Rate.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7809434,yes,
609,History-Based Test Case Prioritization for Failure Information,"From regression tests, developers seek to determine not only the existence of faults, but also failure information such as what test cases failed. Failure information can assist in identifying suspicious modules or functions in order to fix the detected faults. In continuous integration environments, this can also help managers of the source code repository address unexpected situations caused by regression faults. We introduce an approach, referred to as AFSAC, which is a test case prioritization technique based on history data, that can be used to effectively obtain failure information. Our approach is composed of two stages. First, we statistically analyze the failure history for each test case to order the test cases. Next, we reorder the test cases utilizing the correlation data of test cases acquired by previous test results. We performed an empirical study on two open-source Apache software projects (i.e., Tomcat and Camel) to evaluate our approach. The results of the empirical study show that our approach provides failure information to testers and developers more effectively than other prioritization techniques, and each prioritizing method of our approach improves the ability to obtain failure information.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7890618,yes,
610,How Does Regression Test Prioritization Perform in Real-World Software Evolution?,"In recent years, researchers have intensively investigated various topics in test prioritization, which aims to re-order tests to increase the rate of fault detection during regression testing. While the main research focus in test prioritization is on proposing novel prioritization techniques and evaluating on more and larger subject systems, little effort has been put on investigating the threats to validity in existing work on test prioritization. One main threat to validity is that existing work mainly evaluates prioritization techniques based on simple artificial changes on the source code and tests. For example, the changes in the source code usually include only seeded program faults, whereas the test suite is usually not augmented at all. On the contrary, in real-world software development, software systems usually undergo various changes on the source code and test suite augmentation. Therefore, it is not clear whether the conclusions drawn by existing work in test prioritization from the artificial changes are still valid for real-world software evolution. In this paper, we present the first empirical study to investigate this important threat to validity in test prioritization. We reimplemented 24 variant techniques of both the traditional and time-aware test prioritization, and investigated the impacts of software evolution on those techniques based on the version history of 8 real-world Java programs from GitHub. The results show that for both traditional and time-aware test prioritization, test suite augmentation significantly hampers their effectiveness, whereas source code changes alone do not influence their effectiveness much.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886932,yes,
611,Improving test efficiency through multiple criteria coverage based test case prioritization using Modified heuristic algorithm,"Test case prioritization involves reordering the test cases in an order that helps in attaining certain performance goals. The rate of fault detection is one of the prime goals that we tend to achieve while doing prioritization. Test cases should run in an order to increase the possibility of fault detection and it should be achieved early during the test life cycle. To reduce the cost and time of regression testing, test case prioritization should be done with the intention of periodically modifying the test suite. The humongous set of test cases makes it redundant and cumbersome for the testers who ensure quality for an end application. The fault detection capability of a prioritized test suite is improved up to 15% using Modified PSO which forms the base algorithms for prioritization. The algorithm illustrated detects serious errors at earlier phases of testing process and effectiveness between prioritized and unprioritized test cases.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7783254,yes,
612,Improving Testing in an Enterprise SOA with an Architecture-Based Approach,"High resource demand for system testing is a major obstacle for continuous delivery. This resource demand can be reduced by prioritizing test cases, e.g., by focusing on tests that cover a lot of functionality. For large-scale systems, like an enterprise SOA, defining such test cases can be difficult for the tester because of the lack of relevant knowledge about the system. We propose an approach for test case prioritization and selection that is based on architectural viewpoint that provides software testers with the required architectural information. We outline how architectural information is used for defining and selecting prioritized test cases. The approach has been developed in close cooperation with the provider of an enterprise SOA in the banking domain in Austria following an action research approach. In addition, the approach has been validated in an industrial case study. Validation showed that there is no further need for manual architectural analysis to be able to prioritize and select test cases. We also show the limitations of our approach as it is based on static code analysis.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7516833,no,
613,Improvising the effectiveness of test suites using differential evolution technique,"The process of testing any software system is an atrocious task which indeed consumes a ton of effort, and expensive also. Required effort and time to do adequate as well as effective testing get bigger, as the software gets more complexed that can lead to swarm over the project budget or some test cases left uncovered or delay in completion. A suitably generated test suite does not only locate errors but also aid in reducing cost investment associated with the testing process. This paper implements an optimizing technique called as Differential Evolution to improve the effectiveness of test cases using Average Percentage of Fault Detection (APFD) metric. APFD is taken as the fitness function which is to be optimized. In this work, We have performed comparison of our approach with other existing prioritizing approaches and Experimental computations show that Differential Evolution technique achieve better APFD values than other techniques.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7784924,no,
614,Integrating risk assessment and threat modeling within SDLC process,"Risk assessment and threat modeling are conducted for different purpose. The integration of risk assessment and threat modeling process limit the risk of software-based system. Incorporating security in all phases of software development life cycle is a tedious task in many organizations. In design phase of SDLC, the 50 % software defects are identified and detected. Most of the security attacks are happen in application layer. This paper explains the combined use of risk assessment and threat model to understand the security risk of an application. We also discuss how the model may be identifying threats and how to frame threat prioritization for threat category. Finally, we recommend understanding of risk of detection and creating a fair environment to reduce the likelihood of committing criminal acts by attackers.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7823275,no,
615,Investigating the Effects of Balanced Training and Testing Datasets on Effort-Aware Fault Prediction Models,"To prioritize software quality assurance efforts, fault prediction models have been proposed to distinguish faulty modules from clean modules. The performances of such models are often biased due to the skewness or class imbalance of the datasets considered. To improve the prediction performance of these models, sampling techniques have been employed to rebalance the distribution of fault-prone and non-fault-prone modules. The effect of these techniques have been evaluated in terms of accuracy/geometric mean/F1-measure in previous studies; however, these measures do not consider the effort needed to fix faults. To empirically investigate the effect of sampling techniques on the performance of software fault prediction models in a more realistic setting, this study employs Norm(P<sub>opt</sub>), an effort-aware measure that considers the testing effort. We performed two sets of experiments aimed at (1) assessing the effects of sampling techniques on effort-aware models and finding the appropriate class distribution for training datasets (2) investigating the role of balanced training and testing datasets on performance of predictive models. Of the four sampling techniques applied, the over-sampling techniques outperformed the under-sampling techniques with Random Over-sampling performing best with respect to the Norm(P<sub>opt</sub>) evaluation measure. Also, performance of all the prediction models improved when sampling techniques were applied between the rates of (20-30)% on the training datasets implying that a strictly balanced dataset (50% faulty modules and 50% clean modules) does not result in the best performance for effort-aware models. Our results also indicate that performances of effort-aware models are significantly dependent on the proportions of the two types of the classes in the testing dataset. Models trained on moderately balanced datasets are more likely to withstand fluctuations in performance as the class distribution in the testing data varies.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7552003,no,
616,MACKE: Compositional analysis of low-level vulnerabilities with symbolic execution,"Concolic (concrete+symbolic) execution has recently gained popularity as an effective means to uncover non-trivial vulnerabilities in software, such as subtle buffer overflows. However, symbolic execution tools that are designed to optimize statement coverage often fail to cover potentially vulnerable code because of complex system interactions and scalability issues of constraint solvers. In this paper, we present a tool (MACKE) that is based on the modular interactions inferred by static code analysis, which is combined with symbolic execution and directed inter-procedural path exploration. This provides an advantage in terms of statement coverage and ability to uncover more vulnerabilities. Our tool includes a novel feature in the form of interactive vulnerability report generation that helps developers prioritize bug fixing based on severity scores. A demo of our tool is available at https://youtu.be/icC3jc3mHEU.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582815,no,
617,Minimum complexity APP prioritization by bandwidth apportioning in smart phones,"The volume of best effort traffic is exploded by rapid adoption of peer-to-peer and content applications. Smart phone consumers are spending more times on applications which include video and music streaming, playing games, video chatting, social media like uploading photos to Facebook, Twitter etc. Many such applications are always running in background and sometimes come in foreground based on user preferences. In this work we propose an approach to improve the user experience by giving more bandwidth to preferred applications. We describe a preliminary model explaining our technique in detail. Further, we validate our proposal using real time test setup with Wireshark traffic analyzer, and results are detailed with respect to (1) Percentage of network share (2) Jitter experience and (3) Time taken for the algorithm to adapt. Proposed algorithm has been tested in two different platforms such as Android and Tizen. Our preliminary observations show that our proposed algorithm allocates more bandwidth to high priority applications while maintaining the low priority APPs are intact with above minimum bandwidth. Our approach gives users better jitter free experience for video streaming (high priority) applications in both Android (KitKat) and Tizen (Z1) platforms.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7564972,no,
618,Mixed-Criticality Systems as a Service for Non-critical Tasks,"Mixed-Criticality Systems are capable of accommodating tasks of varying criticality. In this paper, these are [life, mission, and non-critical]. Tasks usually have an overestimated execution time to allow for the Worst Case Execution Time (WCET). When these tasks finish execution prior to their allotted execution time due to pessimistic assumptions present in the static analysis of the system. The surplus time is used to accommodate tasks with tolerance for deadline-misses. Non-critical tasks are often treated in a ƒ?best-effortƒ? capacity where no quality of service is considered. When processor utilisation is not overconstrained, all deadlines will be met. However, in cases where not enough processing resources exist to meet all deadlines for non-critical tasks, the allotted time for the non-critical tasks must be rationed between non-critical tasks. This paper proposes a novel method of prioritising non-critical tasks. By treating task execution as a service, non-critical tasks with unbounded deadline miss tolerance are given a Grade of Service for their met deadlines. This Grade of Service is used for the dynamic scheduling of non-critical tasks. Four different scheduling algorithms were tested with the proposed Highest Penalty First algorithm for distributing the effort of task execution amongst non-critical tasks in a proportionate manner and showing superior fairness of task execution compared to all other tested algorithms.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7515632,no,
619,Model-based test case prioritization using ACO: A review,"Regression testing is very costly and inevitable activity of maintenance that is performed to ensure whether the modified software is valid or not. Running all the test cases of a test suit within given limited time and cost constraints is not possible. So, to cover the maximum number of faults in comparatively less time, it is necessary to prioritize the test cases. To solve the time constraint test case prioritization problems Ant Colony optimization (ACO) is a better approach. This paper presents a review on test case prioritization from a given test suite using ACO.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7913140,yes,
620,Modified ACO to maintain diversity in regression test optimization,"Regression testing is unavoidable maintenance activity that is performed several times in software development life cycle. Optimization of regression test case is required to minimize the test case (which will in-turn reduce the time and cost of testing) and to find the fault in early testing activity. The two widely used regression test case optimization techniques, namely, selection and prioritization are recently found to be integrated with different metaheuristic algorithms for fruitful regression test cases. Among the various meta-heuristic algorithms, Ant colony optimization (ACO) algorithm is most popularly used. ACO will try to find the smallest path out all the test cases and it is not sufficient because it will not cover all the test cases which are needed. In this paper we have proposed a modified ant colony optimization to solve test cases in huge search space. The modified algorithm selects the best test cases that find the maximum fault in minimum time.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7507970,yes,
621,Multi-objective test report prioritization using image understanding,"In crowdsourced software testing, inspecting the large number of test reports is an overwhelming but inevitable software maintenance task. In recent years, to alleviate this task, many text-based test-report classification and prioritization techniques have been proposed. However in the mobile testing domain, test reports often consist of more screenshots and shorter descriptive text, and thus text-based techniques may be ineffective or inapplicable. The shortage and ambiguity of natural-language text information and the well defined screenshots of activity views within mobile applications motivate our novel technique based on using image understanding for multi-objective test-report prioritization. In this paper, by taking the similarity of screenshots into consideration, we present a multi-objective optimization-based prioritization technique to assist inspections of crowdsourced test reports. In our technique, we employ the Spatial Pyramid Matching (SPM) technique to measure the similarity of the screenshots, and apply the natural-language processing technique to measure the distance between the text of test reports. Furthermore, to validate our technique, an experiment with more than 600 test reports and 2500 images is conducted. The experimental results show that image-understanding techniques can provide benefit to test-report prioritization for most applications.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582758,no,
622,Negative Effects of Bytecode Instrumentation on Java Source Code Coverage,"Code coverage measurement is an important element in white-box testing, both in industrial practice and academic research. Other related areas are highly dependent on code coverage as well, including test case generation, test prioritization, fault localization, and others. Inaccuracies of a code coverage tool sometimes do not matter that much but in certain situations they can lead to serious confusion. For Java, the prevalent approach to code coverage measurement is to use bytecode instrumentation due to its various benefits over source code instrumentation. However, if the results are to be mapped back to source code this may lead to inaccuracies due to the differences between the two program representations. In this paper, we systematically investigate the amount of differences in the results of these two Java code coverage approaches, enumerate the possible reasons and discuss the implications on various applications. For this purpose, we relied on two widely used tools to represent the two approaches and a set of benchmark programs from the open source domain.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7476645,no,
623,Neuro-fuzzy based approach to event driven software testing: A new opportunity,"Event Driven Software (EDS) testing is a very challenging task as a large number of events can be invoked by users. So far it is difficult to test all the user inputs invoked, therefore, test case prioritization is essentially required for giving more priority to test cases which reveal higher faults comparatively. We have proposed test case prioritization for EDS: as the Event Type, Interaction of Event, and Coverage of Event. Priority assigned in the proposed model uses these factors in Adaptive Neuro-Fuzzy Inference System (ANFIS) MATLAB Toolbox based on Neuro-Fuzzy logic model. Evaluation and validation will be done using Average Percentage of Fault Detection (APFD). APFD rate for prioritized sequence using the proposed Neuro-Fuzzy logic model exhibited 81% rate, whereas, non-prioritized test sequences showed70% suggesting, thereby, that after prioritization; rate of fault detection has improved considerably. Data shows that proposed Neuro-Fuzzy logic model is apt for Test Case Prioritization of EDS Testing.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7975349,no,
624,Opportunistic Competition Overhead Reduction for Expediting Critical Section in NoC Based CMPs,"With the degree of parallelism increasing, performance of multi-threaded shared variable applications is not only limited by serialized critical section execution, but also by the serialized competition overhead for threads to get access to critical section. As the number of concurrent threads grows, such competition overhead may exceed the time spent in critical section itself, and become the dominating factor limiting the performance of parallel applications. In modern operating systems, queue spinlock, which comprises a low-overhead spinning phase and a high-overhead sleeping phase, is often used to lock critical sections. In the paper, we show that this advanced locking solution may create very high competition overhead for multithreaded applications executing in NoC-based CMPs. Then we propose a software-hardware cooperative mechanism that can opportunistically maximize the chance that a thread wins the critical section access in the low-overhead spinning phase, thereby reducing the competition overhead. At the OS primitives level, we monitor the remaining times of retry (RTR) in a thread's spinning phase, which reflects in how long the thread must enter into the high-overhead sleep mode. At the hardware level, we integrate the RTR information into the packets of locking requests, and let the NoC prioritize locking request packets according to the RTR information. The principle is that the smaller RTR a locking request packet carries, the higher priority it gets and thus quicker delivery. We evaluate our opportunistic competition overhead reduction technique with cycle-accurate full-system simulations in GEM5 using PARSEC (11 programs) and SPEC OMP2012 (14 programs) benchmarks. Compared to the original queue spinlock implementation, experimental results show that our method can effectively increase the opportunity of threads entering the critical section in low-overhead spinning phase, reducing the competition overhead averagely by 39.9% (maximally by 61.8%) and accelerating the execution of the Region-of-Interest averagely by 14.4% (maximally by 24.5%) across all 25 benchmark programs.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7551400,no,
625,Optimal test sequence generation using River Formation Dynamics,"Software testing is a complex and exhaustive process, often limited by the resources. Although many approaches for test sequence generation exist in the literature, but none of it is ideal as far as coverage and redundancy is concerned. This paper aims at improving the efficiency of software testing process by generating the optimal test sequences in the control flow graph (CFG) of the program under test (PUT) by using a novel swarm intelligence method called River Formation Dynamics(RFD). RFD is inspired by a natural phenomenon of how drops transformed into river and river into sea. It provides full path coverage with zero edge/transition redundancy. It also tries to prioritize the paths based on their strength, calculated in terms of their traversal by the drops.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7894483,no,
626,PRADA: Prioritizing Android Devices for Apps by Mining Large-Scale Usage Data,"Selecting and prioritizing major device models are critical for mobile app developers to select testbeds and optimize resources such as marketing and quality-assurance resources. The heavily fragmented distribution of Android devices makes it challenging to select a few major device models out of thousands of models available on the market. Currently app developers usually rely on some reported or estimated general market share of device models. However, these estimates can be quite inaccurate, and more problematically, can be irrelevant to the particular app under consideration. To address this issue, we propose PRADA, the first approach to prioritizing Android device models for individual apps, based on mining large-scale usage data. PRADA adapts the concept of operational profiling (popularly used in software reliability engineering) for mobile apps - the usage of an app on a specific device model reflects the importance of that device model for the app. PRADA includes a collaborative filtering technique to predict the usage of an app on different device models, even if the app is entirely new (without its actual usage in the market yet), based on the usage data of a large collection of apps. We empirically demonstrate the effectiveness of PRADA over two popular app categories, i.e., Game and Media, covering over 3.86 million users and 14,000 device models collected through a leading Android management app in China.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7886887,no,
627,Prioritization techniques in combinatorial testing: A survey,"Prioritization techniques have become an indispensable part of the software testing process. They are highly beneficial either due to resource or time constraints or when tester cannot execute the complete test set. Combinatorial test sets are generated with the aim to cover all the possible t-way interactions. In this paper, techniques to prioritize t-way test sets are studied. A comparative study is done of prioritization criteria used by researchers to prioritize t-way test sets. Different evaluation methods used by them are also discussed.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7975314,no,
628,Prioritizing Interaction Test Suites Using Repeated Base Choice Coverage,"Combinatorial interaction testing is a well-studied testing strategy that aims at constructing an effective interaction test suite (ITS) of a specific generation strength to identify interaction faults caused by the interactions among factors. Due to limited testing resources in practice, for example in combinatorial interaction regression testing, interaction test suite prioritization (ITSP) has been proposed to improve the efficiency of testing. An intuitive ITSP strategy that has been widely used in practice is fixed-strength interaction coverage based prioritization (FICBP). FICBP makes use of a property of the ITS: interaction coverage at a fixed prioritization strength. However, a challenge facing FICBP is that, when the ITS is large, the prioritization cost can be very high. In this paper, we propose a new FICBP method that, by repeatedly using base choice coverage (i.e., one-wise coverage) during the prioritization process, improves testing efficiency while maintaining testing effectiveness. The empirical studies show that our method has fault detection capability comparable to current FICBP methods, but obtains more stable results in many cases. Additionally, our method requires considerably less prioritization time than other FICBP methods at different prioritization strengths.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7552005,no,
629,Product feature prioritization using the Hidden Structure method: A practical case at Ericsson,"In this paper, we present a case were we employ the Hidden Structure method to product feature prioritization at Ericsson. The method extends the more common Design Structure Matrix (DSM) approach that has been used in technology management (e.g. project management and systems engineering) for quite some time in order to model complex systems and processes. The hidden structure method focuses on analyzing a DSM based on coupling and modularity theory, and it has been used in a number of software architecture and software portfolio cases. In previous work by the authors the method was tested on organization transformation at Ericsson, however this is the first time it has been employed in the domain of product feature prioritization. Today, at Ericsson, features are prioritized based on a business case approach where each feature is handled isolated from other features and the main focus is customer or market-based requirements. By employing the hidden structure method we show that features are heavily dependent on each other in a complex network, thus they should not be treated as isolated islands. These dependencies need to be considered when prioritizing features in order to save time and money, as well as increase end customer satisfaction.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7806519,no,
630,Radius aware probabilistic testing of deadlocks with guarantees,"Concurrency bugs only occur under certain interleaving. Existing randomized techniques are usually ineffective. PCT innovatively generates scheduling, before executing a program, based on priorities and priority change points. Hence, it provides a probabilistic guarantee to trigger concurrency bugs. PCT randomly selects priority change points among all events, which might be effective for non-deadlock concurrency bugs. However, deadlocks usually involve two or more threads and locks, and require more ordering constraints to be triggered. We interestingly observe that, every two events of a deadlock usually occur within a short range. We generally formulate this range as the bug Radius, to denote the max distance of every two events of a concurrency bug. Based on the bug radius, we propose RPro (Radius aware Probabilistic testing) for triggering deadlocks. Unlike PCT, RPro selects priority change points within the radius of the targeted deadlocks but not among all events. Hence, it guarantees larger probabilities to trigger deadlocks. We have implemented RPro and PCT and evaluated them on a set of real-world benchmarks containing 10 unique deadlocks. The experimental results show that RPro triggered all deadlocks with higher probabilities (i.e., &gt;7.7x times larger on average) than that by PCT. We also evaluated RPro with radius varying from 1 to 150 (or 300). The result shows that the radius of a deadlock is much smaller (i.e., from 2 to 114 in our experiment) than the number of all events. This further confirms our observation and makes RPro meaningful in practice.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582772,no,
631,Signature limits: an entire map of clone features and their discovery in nearly linear time,"We address an increasingly critical problem of identifying the potential signatures for identifying a given family of malware or unwanted software (i.e., or generally any corpus of artifacts of unknown provenance). We address this with a novel methodology designed to create an entire and complete maps of software code clones (copy features in data). We report on a practical methodology, which employs enhanced suffix data structures and partial orderings of clones to compute a compact representation of most interesting clones features in data. The enumeration of clone features is useful for malware triage and prioritization when human exploration, testing and verification is the most costly factor. We further show that the enhanced arrays may be used for discovery of provenance relations in data and we introduce two distinct Jaccard similarity coefficients to measure code similarity in binary artifacts. We illustrate the use of these tools on real malware data including a retro-diction experiment for measuring and enumerating evidence supporting common provenance in Stuxnet and Duqu. The results indicate the practicality and efficacy of mapping completely the clone features in data.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888740,no,
632,Solving exercise generation problems by diversity oriented meta-heuristics,"Evolutionary algorithms used for multi-objective optimization mostly prioritize fitness over diversity to achieve a single optimum fast, or a region in the Pareto-front. In this paper, we argue on that diversity should be a primary objective as well, and we propose a novel approach called EGAL to solve a well-known problem: to generate very different exercises to test students' knowledge in a specific range of topics. We show that focusing on diversity and fitness at the same time result in a better quality of solutions in the resulting population.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7916196,no,
633,Supporting the regression test of multi-variant systems in distributed production scenarios,"Modern manufacturing systems based on cyber-physical systems with a growing amount of software allow frequent updates and reconfigurations to adapt the systems to volatile usage scenarios in the production. A diverse system environment arises even for similar or equal subsystems based on the same platform used at different locations. A major challenge for such systems is the regression test after changes or updates. The resources for the regression test, in a dedicated test environment or deployed to the assembly lines, are limited. To plan the test in the best possible way, a lot of dependencies, relationships and experiences from former tests and tests from other locations have to be considered. This paper describes an assistance system which supports the planning of the regression test in such distributed manufacturing scenarios by combining manual modeling with automated data processing. Therefore the system calculates a cross-location test progress and suggests a prioritized test case sequence.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7733652,no,
634,System-Level Test Case Prioritization Using Machine Learning,"Regression testing is the common task of retesting software that has been changed or extended (e.g., by new features) during software evolution. As retesting the whole program is not feasible with reasonable time and cost, usually only a subset of all test cases is executed for regression testing, e.g., by executing test cases according to test case prioritization. Although a vast amount of methods for test case prioritization exist, they mostly require access to source code (i.e., white-box). However, in industrial practice, system-level testing is an important task that usually grants no access to source code (i.e., black-box). Hence, for an effective regression testing process, other information has to be employed. In this paper, we introduce a novel technique for test case prioritization for manual system-level regression testing based on supervised machine learning. Our approach considers black-box meta-data, such as test case history, as well as natural language test case descriptions for prioritization. We use the machine learning algorithm SVM Rank to evaluate our approach by means of two subject systems and measure the prioritization quality. Our results imply that our technique improves the failure detection rate significantly compared to a random order. In addition, we are able to outperform a test case order given by a test expert. Moreover, using natural language descriptions improves the failure finding rate.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7838169,yes,
635,Targeted Scrum: Applying Mission Command to Agile Software Development,"Software engineering and mission command are two separate but similar fields, as both are instances of complex problem solving in environments with ever changing requirements. Our research hypothesis is that modifications to agile software development based on inspirations from mission command can improve the software engineering process in terms of planning, prioritizing, and communication of software requirements and progress, as well as improving the overall software product. Targeted Scrum is a modification of Traditional Scrum based on three inspirations from Mission Command: End State, Line of Effort, and Targeting. These inspirations have led to the introduction of the Product Design Meeting and modifications of some current Scrum meetings and artifacts. We tested our research hypothesis using a semester-long undergraduate level software engineering class. Students developed two software projects, one using Traditional Scrum and the other using Targeted Scrum. We then assessed how well both methodologies assisted the software development teams in planning and developing the software architecture, prioritizing requirements, and communicating progress. We also evaluated the software product produced by both methodologies. We found that Targeted Scrum did better in assisting the software development teams in the planning and prioritization of the requirements. However, Targeted Scrum had a negligible effect on improving the software development teams external and internal communications. Finally, Targeted Scrum did not have an impact on the product quality by the top performing and worst performing teams. Targeted Scrum did assist the product quality of the teams in the middle of the performance spectrum.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7296686,no,
636,Test case design based technique for the improvement of test case selection in software maintenance,"Test case selection is the maintenance technique regarding the concept of choosing the appropriate representative of the modified program that has to be changed depending upon the new requirements added for the next modification. The main problem of updating software is the amounts of the test suite that is generated for the tests increases, which can drop the performance of using the new code that added to the previous program. According to this, execution and testing time will increase, including the complexity of integrating the codes also increase. Therefore, the test suite minimization approaches are offered to solve these problems. The objective of proposing the design based technique is to refine the competency of using test case selection to control the large programs by applying four algorithms, which are testing test case, classification, deletion, and selection. The result of determining the size reduction is greater than random selection, general regression technique, and test case prioritization as about 28.00%, 17.00%, and 11.00% approximately.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7749202,no,
637,Test Case Prioritization Approach to Improving the Effectiveness of Fault Localization,"Fault localization aims to use testing information from executed test cases to help locate the fault position. However, obtaining testing information (including test results and coverage information) is expensive because it needs much manual effort. How to orderly choose and execute a small number of test cases, and in the meantime achieve a good effectiveness of fault localization in the case of unknowing testing information is still a challenge for us. In this paper, we propose a new test case prioritization algorithm for fault localization, which is based on the rank changes of suspicious values of program elements. Test case which can maximize the improvements of suspicious ranks of program elements may assign the highest priority for execution. A set of empirical studies have been designed and conducted on Siemens programs and four medium-sized programs. The results show that our algorithm can help reduce the debugging effort in terms of the percentage of statements needed to be inspected to locate faults in both single-fault and multi-fault programs.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780195,yes,
638,Test case prioritization based on requirement correlations,"Test case prioritization technique aims to improve test efficiency rate by sorting test cases according to some specific criteria. Requirements play an important role throughout software testing. This paper proposes a test case prioritization method based on requirement correlations. Prioritization of requirements is defined by the users and the developers. This technique focuses on requirements with detected faults after the last regression testing. By readjusting prioritization of fault-related requirements, it can optimize the order of test cases. Experimental results show that this technique exactly contributes to achieving high testing efficiency.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7515934,yes,
639,Test Case Prioritization for Compilers: A Text-Vector Based Approach,"Test case prioritization aims to schedule the execution order of test cases so as to detect bugs as early as possible. For compiler testing, the demand for both effectiveness and efficiency imposes challenge to test case prioritization. In the literature, most existing approaches prioritize test cases by using some coverage information (e.g., statement coverage or branch coverage), which is collected with considerable extra effort. Although input-based test case prioritization relies only on test inputs, it can hardly be applied when test inputs are programs. In this paper we propose a novel text-vector based test case prioritization approach, which prioritizes test cases for C compilers without coverage information. Our approach first transforms each test case into a text-vector by extracting its tokens which reflect fault-relevant characteristics and then prioritizes test cases based on these text-vectors. In particular, in our approach we present three prioritization strategies: greedy strategy, adaptive random strategy, and search strategy. To investigate the efficiency and effectiveness of our approach, we conduct an experiment on two C compilers (i.e., GCC and LLVM), and find that our approach is much more efficient than the existing approaches and is effective in prioritizing test cases.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7515478,yes,
640,Test case prioritization technique based on early fault detection using fuzzy logic,"Regression testing is time consuming and expensive activity in software testing. In Regression testing when any changes made to already tested program it should not affect to other part of program. Regression testing is crucial activities in software testing and maintenance phases. If some part of code is altered then it is mandatory to validate the modified code. Throughout regression testing test case from test suite will be re-executed and re-execution of all the test case will be very expensive. In this paper we present regression test case prioritization for object oriented program. The most important research is how to select efficient and suitable test cases during regression testing from the test suite. To minimize the regression testing cost we have applied prioritization technique. In this paper prioritization is done based on fault detection rate of program, execution time and requirement coverage using fuzzy logic.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7724418,yes,
641,Test case prioritization techniques for software product line: A survey,"Software product line (SPL) testing is a tougher work than testing of single systems. Still testing of each individual SPL product would be perfect but it is too costly in practice. In fact, when the number of features increases then the number of possible products also increases exponentially usually derived from a feature model. Number of features is leading to thousands of different products. Due to cost and time constraints, it is infeasible or large number of effort to run all the test cases in an existing test suite. To decrease the cost of testing, various techniques have been proposed. One of them is test case prioritization (TCP) techniques. Here we presented a survey for TCP techniques for software SPL.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7813841,yes,
642,Test Case Prioritization Using Adaptive Random Sequence with Category-Partition-Based Distance,"Test case prioritization schedules test cases in a certain order aiming to improve the effectiveness of regression testing. Random sequence is a basic and simple prioritization technique, while Adaptive Random Sequence (ARS) makes use of extra information to improve the diversity of random sequence. Some researchers have proposed prioritization techniques using ARS with white-box information, such as code coverage information, or with black-box information, such as string distances of the input data. In this paper, we propose new black-box test case prioritization techniques using ARS, and the diversity of test cases is assessed by category-partition-based distance. Our experimental studies show that these new techniques deliver higher fault-detection effectiveness than random prioritization, especially in the case of smaller ratio of failed test cases. In addition, in the comparison of different distance metrics, techniques with category-partition-based distance generally deliver better fault-detection effectiveness and efficiency, meanwhile in the comparison of different ordering algorithms, our ARS-based ordering algorithms usually have comparable fault-detection effectiveness but much lower computation overhead, and thus are much more cost-effective.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7589817,yes,
643,Test Case Prioritization Using Lexicographical Ordering,"Test case prioritization aims at ordering test cases to increase the rate of fault detection, which quantifies how fast faults are detected during the testing phase. A common approach for test case prioritization is to use the information of previously executed test cases, such as coverage information, resulting in an iterative (greedy) prioritization algorithm. Current research in this area validates the fact that using coverage information can improve the rate of fault detection in prioritization algorithms. The performance of such iterative prioritization schemes degrade as the number of ties encountered in prioritization steps increases. In this paper, using the notion of lexicographical ordering, we propose a new heuristic for breaking ties in coverage based techniques. Performance of the proposed technique in terms of the rate of fault detection is empirically evaluated using a wide range of programs. Results indicate that the proposed technique can resolve ties and in turn noticeably increases the rate of fault detection.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7456343,yes,
644,Test Effectiveness Evaluation of Prioritized Combinatorial Testing: A Case Study,"Combinatorial testing is a widely-used technique to detect system interaction failures. To improve test effectiveness with given priority weights of parameter values in a system under test, prioritized combinatorial testing constructs test suites where highly weighted parameter values appear earlier or more frequently. Such order-focused and frequency-focused combinatorial test generation algorithms have been evaluated using metrics called weight coverage and KL divergence but not sufficiently with fault detection effectiveness so far. We evaluate the fault detection effectiveness on a collection of open source utilities, applying prioritized combinatorial test generation and investigating its correlation with weight coverage and KL divergence.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7589785,no,
645,Testing and Debugging in Continuous Integration with Budget Quotas on Test Executions,"In Continuous Integration, a software application is developed through a series of development sessions, each with limited time allocated to testing and debugging on each of its modules. Test Case Prioritization can help execute test cases with higher failure estimate earlier in each session. When the testing time is limited, executing such prioritized test cases may only produce partial and prioritized execution coverage data. To identify faulty code, existing Spectrum-Based Fault Localization techniques often use execution coverage data but without the assumption of execution coverage priority. Is it possible to decompose these two steps for optimization within individual steps? In this paper, we study to what extent the selection of test case prioritization techniques may reduce its influence on the effectiveness of spectrum-based fault localization, thereby showing the possibility to decompose the process of continuous integration for optimization in workflow steps. We present a controlled experiment using the Siemens suite as subjects, nine test case prioritization techniques and four spectrum-based fault localization techniques. The findings showed that the studied test cases prioritization and spectrum-based fault localization can be customized separately, and, interestingly, prioritization over a smaller test suite can enable spectrum-based fault localization to achieve higher accuracy by assigning faulty statements with higher ranks.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7589824,no,
646,Test-Suite Prioritisation by Application Navigation Tree Mining,"Software tend to evolve over time and so does the test-suite. Regression testing is aimed at assessing that the software evolution did not compromise the working of the existing software components. However, as the software and consequently the test-suite grow in size, the execution of the entire test-suite for each new build becomes infeasible. Techniques like test-suite selection, test-suite minimisation and test-suite prioritisation have been proposed in literature for regression testing. Whilst all of these techniques are essentially an attempt to reduce the testing effort, test-suite selection and minimisation reduce the test-suite size whereas test-suite prioritisation provides a priority order of the test cases without changing the test-suite size. In this work, we focus on test-suite prioritisation. Recently, techniques from data mining have been used for test-suite prioritisation which consider the frequent pairs of interaction among the application interaction patterns. We propose test-Suite prioritisation by Application Navigation Tree mining (t-SANT). First, we construct an application navigation tree by way of extracting both tester and user interaction patterns. Next, we extract frequent sequences of interaction using a sequence mining algorithm inspired from sequential pattern mining. The most frequent longest sequences are assumed to model complex and most frequently used work-flows and hence a prioritisation algorithm is proposed that prioritises the test cases based on the most frequent and longest sequences. We show the usefulness of the proposed scheme with the help of two case studies, an online book store and calculator.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7866754,no,
647,The drawbacks of statement code coverage test case prioritization related to domain testing,"In this paper we study the weaknesses of the test case prioritization algorithms based on statement code coverage and applied to the domain test cases. We present the inconsistency between the principles of domain testing and the selection and prioritization practices over domain test cases on criteria unrelated to the scope of the domain testing. We continue the study by discussing the impact of 100% statement code coverage over the suites of domain test cases, studying why this type of code coverage should not produce effects over the domain test cases. Statement code coverage prioritization techniques related to unit testing, integration testing and regression testing phases are discussed, emphasizing the incompatibility between statement code coverage, domain testing and test case prioritization all at once.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7507373,yes,
648,The Perception of Technical Debt in the Embedded Systems Domain: An Industrial Case Study,"Technical Debt Management (TDM) has drawn the attention of software industries during the last years, including embedded systems. However, we currently lack an overview of how practitioners from this application domain perceive technical debt. To this end, we conducted a multiple case study in the embedded systems industry, to investigate: (a) the expected life-time of components that have TD, (b) the most frequently occurring types of TD in them, and (c) the significance of TD against run-time quality attributes. The case study was performed on seven embedded systems industries (telecommunications, printing, smart manufacturing, sensors, etc.) from five countries (Greece, Netherlands, Sweden, Austria, and Finland). The results of the case study suggest that: (a) maintainability is more seriously considered when the expected lifetime of components is larger than ten years, (b) the most frequent types of debt are test, architectural, and code debt, and (c) in embedded systems the run-time qualities are prioritized compared to design-time qualities that are usually associated with TD. The obtained results can be useful for both researchers and practitioners: the former can focus their research on the most industrially-relevant aspects of TD, whereas the latter can be informed about the most common types of TD and how to focus their TDM processes.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7776447,no,
649,To Be Optimal or Not in Test-Case Prioritization,"Software testing aims to assure the quality of software under test. To improve the efficiency of software testing, especially regression testing, test-case prioritization is proposed to schedule the execution order of test cases in software testing. Among various test-case prioritization techniques, the simple additional coverage-based technique, which is a greedy strategy, achieves surprisingly competitive empirical results. To investigate how much difference there is between the order produced by the additional technique and the optimal order in terms of coverage, we conduct a study on various empirical properties of optimal coverage-based test-case prioritization. To enable us to achieve the optimal order in acceptable time for our object programs, we formulate optimal coverage-based test-case prioritization as an integer linear programming (ILP) problem. Then we conduct an empirical study for comparing the optimal technique with the simple additional coverage-based technique. From this empirical study, the optimal technique can only slightly outperform the additional coverage-based technique with no statistically significant difference in terms of coverage, and the latter significantly outperforms the former in terms of either fault detection or execution time. As the optimal technique schedules the execution order of test cases based on their structural coverage rather than detected faults, we further implement the ideal optimal test-case prioritization technique, which schedules the execution order of test cases based on their detected faults. Taking this ideal technique as the upper bound of test-case prioritization, we conduct another empirical study for comparing the optimal technique and the simple additional technique with this ideal technique. From this empirical study, both the optimal technique and the additional technique significantly outperform the ideal technique in terms of coverage, but the latter significantly outperforms the former two techniques in terms of fault detection. Our findings indicate that researchers may need take cautions in pursuing the optimal techniques in test-case prioritization with intermediate goals.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7314957,yes,
650,Tolerance to complexity: Measuring capacity of development teams to handle source code complexity,"A well defined testing strategy is essential for any software development project. Testing efforts need to be carefully planed and executed in order to ensure effectiveness. Programming failures can represent a high risk for business. In order to mitigate such risk, companies have been increasingly investing more resources on software testing. In despite of massive investments on software testing and extensive collection of static analysis techniques and tools, there are still few conclusive explanations for what causes human programming failures on software. The hypothesis investigated in this paper is that a metric based on development teams characteristics can be more effective to predict defective source code than metrics purely focused on information about source code, alone. Aiming to assist software engineers during testing initiatives, this article presents a new approach to systematically measure capacity of development teams to handle source code complexity. The proposed metric can be effective for raising information and comparing multiple development teams, planning training initiatives and prioritising testing efforts. Experiments were carried out with the entire source code base of device drivers for Linux Operating System. Our approach was able to predict, with 80% of accuracy rate, which development teams introduced more issues from 2010 to 2014.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7844689,no,
651,UML-based reconfigurable middleware for design-level timing verification in model-based approach,"Model-based approaches for the development of software intensive real-time embedded systems allow early verification of timing properties at the design phase. In order to perform such verification, some aspects of the target software platform (i.e. the Real-Time Operating System (RTOS)) need to be considered such as priorities, scheduling policies, etc. However, one of the basic principles of model-based approaches, is to keep RTOS-independence of the design model. Hence, some assumptions on the software platform are implicitly made to achieve timing verification. This approach may lead to a mismatch between the design model and the RTOS-specific model describing the real-time application and thus, at the implementation level, timing properties may be affected. To tackle this issue, we define in this paper a reconfigurable middleware called RT-Mw. This middleware aims to explicitly describe the software assumptions at the design level for timing verification. Such approach allows early verification of these assumptions before the effective deployment which may prevents the mismatch between the design and the RTOS-Specific models. RT-Mw is described using UML modeling language together with the MARTE Standard.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7843037,no,
652,User-Centric Network Provisioning in Software Defined Data Center Environment,"Present data center (DC) network provisioning schemes primarily utilize conventional load-balancing technologies, offering individual application performance improvement. Diversity in application usage however, makes isolated application prioritization a performance caveat for users with varying application trends. The present paper proposes a user profiling approach to capture application trends based on generic flow measurements (NetFlow) and employs the extracted profiles to create DC traffic forwarding policies. The scheme allows operators to define a global profile and application hierarchy based on extracted profiles to prioritize traffic for individual user classes. The proposed design was tested by extracting user profiles from a realistic enterprise network, and further simulated to dynamically manage DC traffic using the software defined networking paradigm. Compared to conventional traffic management schemes, the frame delivery ratio and effective throughput of our design was significantly higher for high priority north-south user traffic as well as the inter-server east-west application traffic.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7796801,no,
653,Using memetic algorithms for test case prioritization in model based software testing,"Building high quality software is one of the main goals in software industry. Software testing is a critical step in confirming the quality of software. Testing is an expensive activity because it consumes about 30% to 50% of all software developing cost. Today much research has been done in generating and prioritizing tests. First, tester should find the most important and critical path in software. They can reduce cost by finding errors and preventing to propagate it in design step. In this paper, a model based testing method is introduced. This method can prioritize tests using activity diagram, control flow graph, genetic and memetic algorithm. Different version of memetic algorithm has been made by stochastic local search, randomize iterative improvement, hill climbing and simulated annealing algorithms. The results show that the using local search methods with genetic algorithm (GA) provide efficiency and produce competitive results in comparison with GA.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7482129,yes,
654,Using Software Metrics Thresholds to Predict Fault-Prone Classes in Object-Oriented Software,"Most code-based quality measurement approaches are based, at least partially, on values of multiple source code metrics. A class will often be classified as being of poor quality if the values of its metrics are above given thresholds, which are different from one metric to another. The metrics thresholds are calculated using various techniques. In this paper, we investigated two specific techniques: ROC curves and Alves rankings. These techniques are supposed to give metrics thresholds which are practical for code quality measurements or even for fault-proneness prediction. However, Alves Rankings technique has not been validated as being a good choice for fault-proneness prediction, and ROC curves only partially on few datasets. Fault-proneness prediction is an important field of software engineering, as it can be used by developers and testers as a test effort indication to prioritize tests. This will allow a better allocation of resources, reducing therefore testing time and costs, and an improvement of the effectiveness of testing by testing more intensively the components that are likely more fault-prone. In this paper, we wanted to compare empirically the selected threshold calculation methods used as part of fault-proneness prediction techniques. We also used a machine learning technique (Bayes Network) as a baseline for comparison. Thresholds have been calculated for different object-oriented metrics using four different datasets obtained from the PROMISE Repository and another one based on the Eclipse project.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7916977,no,
655,Visualization of combinatorial models and test plans,"Combinatorial test design (CTD) is an effective and widely used test design technique. CTD provides automatic test plan generation, but it requires a manual definition of the test space in the form of a combinatorial model. One challenge for successful application of CTD in practice relates to this manual model definition and maintenance process. Another challenge relates to the comprehension and use of the test plan generated by CTD for prioritization purposes. In this work we introduce the use of visualizations as a means to address these challenges. We apply three different forms of visualization, matrices, graphs, and treemaps, to visualize the relationships between the different elements of the model, and to visualize the strength of each test in the test plan and the relationships between the different tests in terms of combinatorial coverage. We evaluate our visualizations via a user survey with 19 CTD practitioners, as well as via two industrial projects in which our visualization was used and allowed test designers to get vital insight into their models and into the coverage provided through CTD generated test plans.",2016,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582753,no,
656,10th International Workshop on Search-Based Software Testing (SBST 2017),"Summary form only given, as follows. SBST 2017 Workshop Summary. Search-Based Software Testing (SBST) is the application of optimizing search techniques (for example, Genetic Algorithms) to solve problems in software testing. SBST is used to generate test data, prioritize test cases, minimize test suites, reduce human oracle cost, verify software models, test service- orientated architectures, construct test suites for interaction testing, and validate real-time properties. The objectives of this workshop are to bring together researchers and industrial practitioners from SBST and the wider software engineering community to share experience and provide directions for future research, and to encourage the use of search techniques to combine aspects of testing with other aspects of the software engineering lifecycle.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7967910,no,
657,A Fault Based Approach to Test Case Prioritization,"Regression testing is performed to ensure that the no new faults have been introduced in the software after modification and the software continues to work correctly. Regression testing is an expensive process because the test suite might be too large to execute in full. Thus to reduce the cost of such testing, regression testing techniques are used. One such technique is test case prioritization. Software testers assign priority to each test case to make sure that the test cases with higher priorities are executed first, in case of not having enough resources to execute the whole test suite. Test case prioritization is mainly used to increase fault detection rate of test suite which is the measure of how early faults are detected. In this paper, we propose an approach which exploits mutation testing in order to assign priorities to test cases. Using mutation testing, we introduce different faults in original program thus creating a number of mutated copies of the program and test case that exposes maximum number of these faults is given the highest priority. We report the outcomes of our experiments in which we applied our technique to test suites and calculated the fault detection rates produced by the prioritized test suites, comparing those rates of fault detection to the rates achieved by existing prioritization technique. The resulting data shows that prioritization technique proposed improved the fault detection rate of test suites.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8261011,yes,
658,A Framework for Combining and Ranking Static Analysis Tool Findings Based on Tool Performance Statistics,"This paper proposes a conceptual, performance-based ranking framework that prioritises the output of multiple Static Analysis Tools, to improve the tool effectiveness and usefulness. The framework weights the performance of Static Analysis Tools per defect type and cross-validates the findings between different Static Analysis Tools' reports. An initial validation shows the potential benefits of the proposed framework.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8004389,no,
659,A General Framework for Dynamic Stub Injection,"Stub testing is a standard technique to simulate the behavior of dependencies of an application under test such as the file system. Even though existing frameworks automate the actual stub injection, testers typically have to implement manually where and when to inject stubs, in addition to the stub behavior. This paper presents a novel framework that reduces this effort. The framework provides a domain specific language to describe stub injection strategies and stub behaviors via declarative rules, as well as a tool that automatically injects stubs dynamically into binary code according to these rules. Both the domain specific language and the injection are language independent, which enables the reuse of stubs and injection strategies across applications. We implemented this framework for both unmanaged (assembly) and managed (.NET) code and used it to perform fault injection for twelve large applications, which revealed numerous crashes and bugs in error handling code. We also show how to prioritize the analysis of test failures based on a comparison of the effectiveness of stub injection rules across applications.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985696,no,
660,A Greedy-Based Method for Modified Condition/Decision Coverage Testing Criterion,"During software regression testing, the code coverage of target program is a crucial factor while we perform test case reduction and prioritization. Modified Condition/ Decision Coverage (MC/DC) is one of the most strict and high-accuracy criterion in code coverage and it is usually considered necessary for adequate testing of critical software. In the past, Hayhurst et al proposed a method to implement the MC/DC criterion that complies with regulatory guidance for DO-178B level A software. Hayhurst's MC/DC approach was to find some test cases which are satisfied by MC/DC criterion for each operator (and, or, not, or xor) in the Boolean expression. However, there could be some problems when using Hayhurst's MC/DC approach to select test cases. In this paper, we discuss how to improve and/or enhance Hayhurst's MC/DC approach by using a greedy-based method. Some experiments are performed based on real programs to evaluate as well as compare the performance of our proposed and Hayhurst's approaches.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8069087,no,
661,A novel approach to multiple criteria based test case prioritization,"When software is modified, it is retested to ensure that no new faults have been introduced in the previously tested code and it still works correctly. Such testing is known as regression testing. The cost of regression testing is high because the original program has large number of test cases. It is not feasible to execute all test cases for regression testing. Test suite minimization, test case selection and test case prioritization are cost commonly used techniques in regression testing to reduce the cost of regression testing. While test suite minimization and test case selection techniques select a subset of test cases, test case prioritization does not eliminate any test case, it only orders the test cases with the objective of increasing the fault detection rate. Prioritization is usually preferred over other two approaches because it does not involve the risk of losing useful test cases. Prioritization techniques assign priority to each test case on the basis of some coverage criteria. A number of different single criterion and multiple criteria based prioritization techniques have been proposed in the literature. Multiple criteria based prioritization techniques perform better than single criterion based prioritization techniques. The existing multiple criteria based prioritization techniques combine the criteria in such a way that ƒ??Additionalƒ? strategy cannot be applied on them. In this paper, we propose a new multiple criteria based test case prioritization algorithm that considers two criteria to prioritize test cases using ƒ??Additionalƒ? strategy. One criterion is considered as primary and other is considered as secondary. Primary criterion is used to prioritize the test cases whereas secondary criterion is used to break the tie among test cases when two or more test cases provide equal coverage of entities of first criterion. Our proposed multiple criteria based prioritization algorithm performs better than the existing prioritization techniques.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8281742,yes,
662,A QoS Guaranteed Technique for Cloud Applications Based on Software Defined Networking,"Due to the centralized control, network-wide monitoring and flow-level scheduling of software-defined-networking (SDN), it can be utilized to achieve quality of service (QoS) for cloud applications and services, such as voice over IP, video conference, and online games. However, most existing approaches stay at the QoS framework design and test level, while few works focus on studying the basic QoS techniques supported by SDN. In this paper, we enable SDN with QoS guaranteed abilities, which could provide end-to-end QoS routing for each cloud user service. First of all, we implement an application identification technique on SDN controller to determine required QoS levels for each application type. Then, we implement a queue scheduling technique on SDN switch. It queues the application flows into different queues and schedules the flows out of the queues with different priorities. At last, we evaluate the effectiveness of the proposed SDN-based QoS technique through both theoretical and experimental analysis. Theoretical analysis shows that our methods can provide differentiated services for the application flows mapped to different QoS levels. Experiment results show that when the output interface has sufficiently available bandwidth, the delay can be reduced by 28% on average. In addition, for the application flow with the highest priority, our methods can reduce 99.99% delay and increase 90.17% throughput on average when the output interface utilization approaches to the maximum bandwidth limitation.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048495,no,
663,A Regression Test Case Prioritization Algorithm Based on Program Changes and Method Invocation Relationship,"Regression testing is essential for assuring the quality of a software product. Because rerunning all test cases in regression testing may be impractical under limited resources, test case prioritization is a feasible solution to optimize regression testing by reordering test cases for the current testing version. In this paper, we propose a new test case prioritization algorithm based on program changes and method (function) invocation relationship. Combining the estimated risk value of each program method (function) and the method (function) coverage information, the fault detection capability of each test case can be calculated. The algorithm reduces the prioritization problem to an integer linear programming (ILP) problem, and finally prioritizes test cases according to their fault detection capabilities. Experiments are conducted on 11 programs to validate the effectiveness of our proposed algorithm. Experimental results show that our approach is more effective than some well studied test case prioritization techniques in terms of average percentage of fault detected (APFD) values.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8305939,yes,
664,A survey on prioritization regression testing test case,"Regression testing is a process used to measure the validity of the system during software maintenance. Regression testing process is very expensive and must be introduced each time a modification occurs in software to ensure that the system still work and that the new modification doesn't cause any bugs, this process depends on selecting test cases from a test suite. Selection of test cases is very critical since it affect the regression testing time and effort, so that many algorithms exist to enhance regression testing process. One of the methods used to make enhancements is to select test cases using prioritization testing techniques. Prioritization techniques find the bugs early to improve regression testing efficiency by prioritizing the test cases. In this paper many regression testing prioritization techniques were reviewed and analyzed.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8079958,yes,
665,"A Test Case Recommendation Method Based on Morphological Analysis, Clustering and the Mahalanobis-Taguchi Method","This paper focuses on the content of test cases, and categorizes test cases into clusters using the similarity between test cases, their degree of similarity is obtained through a morphological analysis. If there are two similar test cases, they would test the same or similar functionalities in similar but different conditions. Thus, when one of them is run for a regression testing, the remaining one should be run as well, in order to reduce a risk of overlooking regressions. Once a test engineer decides to run a set of test cases, the method proposed in this paper can recommend adding similar test cases to their candidate set. The proposed method also considers the priorities of recommended test cases by using the Mahalanobis-Taguchi method. This paper reports on an empirical study with an industrial software product. The results show that the proposed method is useful to prevent overlooking regressions.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7899026,yes,
666,Adapting code maintainability to bat-inspired test case prioritization,"Time and budget constraints in developing a software create an adverse effect in terms of the adequacy of maintenance and test processes. This case can be considered as a burden for persons who account for test processes. In order to alleviate this burden, test case prioritization is one of the solutions. A nature-inspired method namely BITCP, which was developed based on bat algorithm, produced promising results. However, this method does not involve test case elements with respect to the code maintainability. In this work, the correlation between some code maintainability indicators including WMC, LCOM, and Coupling and cyclomatic complexity is investigated. IMPBITCP appears after adapting the results of the investigation to BITCP. The method is then compared with well known alternatives such as greedy-search, particle swarm optimization, and BITCP. The experiment involving six open source project showed that IMPCBITCP outperformed the others with respect to the APFD. The findings of the work indicates that if the factors affecting code maintenance are considered while developing test case prioritization techniques, APFD results becomes high and stable.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8001134,no,
667,ALOJA: A Framework for Benchmarking and Predictive Analytics in Hadoop Deployments,"This article presents the ALOJA project and its analytics tools, which leverages machine learning to interpret big data benchmark performance data and tuning. ALOJA is part of a long-term collaboration between Barcelona Supercomputing Center and Microsoft to automate the characterization of cost-effectiveness on big data deployments, currently focusing on Hadoop. Hadoop presents a complex run-time environment, where costs and performance depend on a large number of configuration choices. The ALOJA project has created an open, vendor-neutral repository, featuring over 40000 Hadoop job executions and their performance details. The repository is accompanied by a test bed and tools to deploy and evaluate the cost-effectiveness of different hardware configurations, parameters, and cloud services. Despite early success within ALOJA, a comprehensive study requires automation of modeling procedures to allow an analysis of large and resource-constrained search spaces. The predictive analytics extension, ALOJA-ML, provides an automated system allowing knowledge discovery by modeling environments from observed executions. The resulting models can forecast execution behaviors, predicting execution times for new configurations and hardware choices. That also enables model-based anomaly detection or efficient benchmark guidance by prioritizing executions. In addition, the community can benefit from ALOJA data sets and framework to improve the design and deployment of big data applications.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7312954,no,
668,An Empirical Comparison of Similarity Measures for Abstract Test Case Prioritization,"Test case prioritization (TCP) attempts to order test cases such that those which are more important, according to some criterion or measurement, are executed earlier. TCP has been applied in many testing situations, including, for example, regression testing. An abstract test case (also called a model input) is an important type of test case, and has been widely used in practice, such as in configurable systems and software product lines. Similarity-based test case prioritization (STCP) has been proven to be cost-effective for abstract test cases (ATCs), but because there are many similarity measures which could be used to evaluate ATCs and to support STCP, we face the following question: How can we choose the similarity measure(s) for prioritizing ATCs that will deliver the most effective results? To address this, we studied fourteen measures and two popular STCP algorithms - local STCP (LSTCP), and global STCP (GSTCP). We also conducted an empirical study of five realworld programs, and investigated the efficacy of each similarity measure, according to the interaction coverage rate and fault detection rate. The results of these studies show that GSTCP outperforms LSTCP - in 61% to 84% of the cases, in terms of interaction coverage rates; and in 76% to 78% of the cases with respect to fault detection rates. Our studies also show that Overlap, the simplest similarity measure examined in this study, could obtain the overall best performance for LSTCP; and that Goodall3 has the best performance for GSTCP.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8029584,yes,
669,An Empirical Examination of Abstract Test Case Prioritization Techniques,"Abstract test case prioritization (ATCP) aims at ordering abstract test case in order to increase the speed at which faults are detected, potentially increasing the fault detection rate. This paper empirically examines possible ATCP techniques, according to the following four categories: non-information-guided prioritization (NIGP), interaction coverage based prioritization (ICBP), input-model mutation based prioritization (IMBP), and similarity based prioritization (SBP). We found that the ICBP category has better testing effectiveness than others, according to fault detection rates. Surprisingly, we found that NIGP can achieve similar performance to IMBP, and that SBP can sometimes achieve even better rates of fault detection than some ICBP techniques.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7965282,yes,
670,An empirical study on clustering approach combining fault prediction for test case prioritization,"Using Clustering algorithm to improve the effectiveness of test case prioritization has been well recognized by many researchers. Software fault prediction has been one of the active parts of software engineering, but to date, there are few test cases prioritization technique using fault prediction. We conjecture that if the code has a fault-proneness, the test cases covering the code will find fault with higher probability. In addition, most of the existing test cases prioritization techniques using clustering algorithm don't consider the number of clusters. Thus, in this paper, we design a test case prioritization based on clustering approach combining fault prediction. We consider the method to obtain the best number of clusters and the clustering prioritization based on the results of fault prediction. To investigate the effectiveness of our approach, we perform an empirical study using an object which contains test cases and faults. The experiment results indicate that our techniques can improve the effectiveness of test case prioritization.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7960104,yes,
671,An empirical study on clustering approach combining fault prediction for test case prioritization,"Using Clustering algorithm to improve the effectiveness of test case prioritization has been well recognized by many researchers. Software fault prediction has been one of the active parts of software engineering, but to date, there are few test cases prioritization technique using fault prediction. We conjecture that if the code has a fault-proneness, the test cases covering the code will findfault with higher probability. In addition, most of the existing test cases prioritization techniques using clustering algorithm don't consider the number of clusters. Thus, in this paper, we design a test case prioritization based on clustering approach combining fault prediction. We consider the method to obtain the best number of clusters and the clustering prioritization based on the results of fault prediction. To investigate the effectiveness of our approach, we perform an empirical study using an object which contains test cases and faults. The experiment results indicate that our techniques can improve the effectiveness of test case prioritization.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7960105,yes,
672,An Empirical Study on the Effect of Testing on Code Quality Using Topic Models: A Case Study on Software Development Systems,"Previous research in defect prediction has proposed approaches to determine which files require additional testing resources. However, practitioners typically create tests at a higher level of abstraction, which may span across many files. In this paper, we study software testing, especially test resource prioritization, from a different perspective. We use topic models to generate topics that provide a high-level view of a system, allowing developers to look at the test case coverage from a different angle. We propose measures of how well tested and defect prone a topic is, allowing us to discover which topics are well tested and which are defect prone. We conduct case studies on the histories of Mylyn, Eclipse, and NetBeans. We find that 34-78% of topics are shared between source code and test files, indicating that we can use topic models to study testing; well-tested topics are usually less defect prone, defect-prone topics are usually undertested; we can predict which topics are defect prone but not well tested with an average precision and recall of 75% and 77%, respectively; our approach complements traditional prediction-based approaches by saving testing and code inspection effort; and our approach is not particularly sensitive to the parameters that we use.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7949108,yes,
673,An extended adaptive process model for agile software development methodology,"Agile methodologies focus on the agility for the development of software. Among various agile methods, eXtreme Programming (XP) is the most adopted agile method. XP has been used for the development of other agile methods, for example, ƒ??adaptive software development process modelƒ? (ASDPM), which is the modified approach of XP. ASDPM was proposed to support the following activities: ƒ??(a) communication and planning, (b) analysis, (c) design and development, and (d) testingƒ?. Based on our literature review of ASDPM, we identify that ASDPM does not support the following: (i) how to identify the different types of agile team members who will participate during the communication and planning phase?; and (ii) how to deliver the most important requirements of the software during analysis phase?. Therefore, in order to address this issue and to strengthen the analysis phase of agile process models, in this paper we propose an extended adaptive process model (APM) for agile software development methodology. This method includes the following steps: (1) identification of agile team members, (2) communication and planning, (3) analysis includes the computation of function point of each requirement; and the selection and prioritization of the requirements, (4) design and development, (5) testing. Finally, the utilization of the proposed method is demonstrated with the help of Institute Examination System, as a case study.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8342770,no,
674,An Ilities-Driven Methodology for the Analysis of Gaps of Stakeholders Needs in Space Systems Conceptual Design,"The new generation of space-based services includes large-scale, integrated, and distributed informational systems for which traditional system engineering approaches show some limits in delivering the ƒ??big picture.ƒ? Missing the view of the full range of design options, or prematurely translating the perceived stakeholders needs into design requirements, is often a consequence of insufficient regard to the end-users priorities. Objective of the present research is to bring to light the gaps extant between what system architects prioritize, and the preferences of potential system users. To this purpose, the proposed method aims at incorporating lifecycle properties (-ilities) in the concept design phase, by submitting attributes of these properties for the evaluation of two stakeholders representative groups. The case study refers to the integration of environmental measurements, coming from a global-navigation-satellite-systems-based remote sensing satellite constellation, as complementary data to the traditional weather-forecasting service, resulting in a new system of systems. The method runs through an interview-based quality function deployment process and collaborative sessions of teams of stakeholders. The strength of the formulation relies on the ability to treat a quantitative measure of the gaps extant between system desired capabilities as perceived by architects, and real end-user needs. The method can be potentially tested in a concurrent design environment as a complementary tool for eliciting requirements and suggesting the areas where investments and resources should be preferably allocated. Results can be used by researchers as pieces of knowledge to be further investigated, and by practitioners in development projects, taking into account that they are preliminary findings.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498637,no,
675,An Industrial Study of Natural Language Processing Based Test Case Prioritization,"In mobile application development, the frequentsoftware release limits the testing time resource. In order todetect bugs in early phases, researchers proposed various testcase prioritization (TCP) techniques in past decades. In practice, considering that some test case is described or contains text, theresearchers also employed Natural Language Processing (NLP)to assist the TCP techniques. This paper conducted an extensiveempirical study to analyze the performance of three NLP basedTCP technologies, which is based on 15059 test cases from 30industrial projects. The result shows that all of these threestrategies can help to improve the efficiency of software testing, and the Risk strategy achieved the best performance across thesubject programs.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7928016,no,
676,Automated System-Level Regression Test Prioritization in a Nutshell,"Westermo Research and Development has developed SuiteBuilder, an automated tool to determine an effective ordering of regression test cases. The ordering is based on factors such as fault detection success, the interval since the last execution, and code modifications. SuiteBuilder has enabled Westermo to overcome numerous regression-testing problems, including lack of time to run a complete regression suite, failure to detect bugs in a timely manner, and repeatedly omitted tests. In the tool's first two years of use, reordered test suites finished in the available time, most fault-detecting test cases were located in the first third of suites, no important test case was omitted, and the necessity for manual work on the suites decreased greatly.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974685,yes,
677,Autonomous observation of multiple USVs from UAV while prioritizing camera tilt and yaw over UAV motion,"This paper proposes a scheme for observing cooperative Unmanned Surface Vehicles (USV), using a rotorcraft Unmanned Aerial Vehicle (UAV) with camera movements (tilt and yaw) prioritized over UAV movements. Most of the current researches consider a fixed-wing type UAV for surveillance of multiple moving targets (MMT), whose functionality is limited to just UAV movements. Experiments in simulation are conducted and verified that, prioritizing camera movements increased the number of times each USV is visited (on an average by 5.68 times more), decreased the percentage of the duration that the UAV is not observing any USV (on an average by 19.8%) and increased the efficiency by decreasing the distance traveled by the UAV (on an average by 747 pixels) for the six test cases. Autonomous repositioning of the UAV at regular intervals to observe USVs during a disaster scenario will provide the operator with better situational awareness. Using a rotorcraft over a fixed-wing type UAV provides the operator with a flexibility of observing the target for the required duration by hovering and freedom of unrestricted movements, which help improve the efficiency of target observation.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8088154,no,
678,Big RF Data Assisted Cognitive Radio Network Coexistence in 3.5GHz Band,"In this paper, big Radio Frequency (RF) data assisted optimization is considered for future wireless networks employing cognitive radio technology with machine learning capability. A cognitive radio network (CRN) with multiple Secondary Users (SUs) may coexist with other wireless systems such as Small Cells (SC) and Radar systems, both Primary Users (PUs) with different level of priorities. Traditional spectrum sensing typically only gives information about the presence or absence of a PU. However, when multiple heterogeneous systems coexist, it becomes imperative to acquire the knowledge of the systems operating in a specific band at a particular time so as to choose an appropriate transmission strategy. In this work, we take advantage of the learning capability of a Neural Network Predictor (NNP) to obtain the statistics of the coexisted wireless systems from the RF traces collected in our Universal Software Radio Peripheral (USRP) based test bed. The NNP is able to learn the features of the RF traces and make accurate prediction of the signals prevalent in the wireless environment. Because of the augmented information learned from the RF traces, a novel optimization problem incorporating the outputs from the NNP is formulated to maximize the throughput of the CRN. The solution is derived using Karush- Kuhn-Tucker (KKT) and extensive simulations using the real RF traces are carried out. It is demonstrated that the NNP can detect the type and number of coexisted users reliably and the proposed scheme will improve the performance of the coexisted CRN.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8038357,no,
679,CBGA-ES: A Cluster-Based Genetic Algorithm with Elitist Selection for Supporting Multi-Objective Test Optimization,"Multi-objective search algorithms (e.g., non-dominated sorting genetic algorithm II (NSGA-II)) have been frequently applied to address various testing problems requiring multi-objective optimization such as test case selection. However, existing multi-objective search algorithms have certain randomness when selecting parent solutions for producing offspring solutions. In the worse case, suboptimal parent solutions may result in offspring solutions with bad quality, and thus affect the overall quality of the next generation. To address such a challenge, we propose a cluster-based genetic algorithm with elitist selection (CBGA-ES) with the aim to reduce such randomness for supporting multi-objective test optimization. We empirically compared CBGA-ES with random search, greedy (as baselines) and four commonly used multi-objective search algorithms (e.g., NSGA-II) using two industrial and one real world test optimization problem, i.e., test suite minimization, test case prioritization, and test case selection. The results showed that CBGA-ES significantly outperformed the baseline algorithms (e.g., greedy), and the four selected search algorithms for all the three test optimization problems. CBGA-ES managed to outperform more than 75% of the objectives for all the four algorithms in each test optimization problem. Moreover, CBGA-ES was able to improve the quality of the solutions for an average of 32.5% for each objective as compared to the four algorithms for the three test optimization problems.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927990,no,
680,Classification model for test case prioritization techniques,"Regression Testing is mainly done in software maintenance aiming to assure that the changes made in the software have correctly been implemented and also to achieve the confidence that the modifications have not affected the other parts of the software. It is very costly and expensive technique. There are number of techniques present in literature that focus on achieving various testing objectives early in the process and hence reduces its cost. Despite of that, testers usually prefer only few already known techniques for test case prioritization. The main reason behind is the absence of guidelines for the selection of TCP techniques. Hence, this piece of research introduces a novel approach for classification of TCP techniques using fuzzy logic to support the efficient selection of test case prioritization techniques. This work is an extension of already proposed selection schema for test case prioritization techniques. To perform the validation of proposed approach results are compared with other classification techniques using Weka tool. The analysis clearly shows the effectiveness of proposed approach as compared to others in terms of its accuracy.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8229925,yes,
681,Cloud-based parallel concolic execution,"Path explosion is one of the biggest challenges hindering the wide application of concolic execution. Although several parallel approaches have been proposed to accelerate concolic execution, they neither scale well nor properly handle resource fluctuations and node failures, which often happen in practice. In this paper, we propose a novel approach, named PACCI, which parallelizes concolic execution and adapts to the drastic changes of computing resources by leveraging cloud infrastructures. PACCI tailors concolic execution to the MapReduce programming model and takes into account the features of cloud infrastructures. In particular, we tackle several challenging issues, such as making the exploration of different program paths independently and constructing an extensible path exploration module to support the prioritization of test inputs from a global perspective. Preliminary experimental results show that PACCI is scalable (e.g., gaining about 20?? speedup using 24 nodes) and its efficiency declines slightly about 5% and 6.1% under resource fluctuations and node failures, respectively.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7884649,no,
682,Comparison analysis of two test case prioritization approaches with the core idea of adaptive,"Test case prioritization problem (TCP) has been widely discussed. It aims to controlling the test case execution sequence to improve the effectiveness of software testing. The key issue of TCP is to identify which test cases can provide useful information for failure detection and fault localization. So far, many TCP approaches have been proposed. Among them, Adaptive Random Testing (ART) and Dynamic Random Testing (DRT) are two of the most popular approaches to solve TCP with a basic idea borrowed from Cybernetics: adaptive. Both ART and DRT has been widely explored and observed with good performances in experimental studies. Nevertheless, although they are proposed by two related research groups, they are developed independently and in parallel. In fact, their mechanisms have many similarities and differences and, for the completeness of the domains of Adaptive Testing and Software Cybernetics, many issues concerning the comparison between these two approaches should be further explored. In this paper, we specifically explores the relationship between these two adaptive TCP approaches. Their mechanisms are described respectively with explorations of their distinctions, similarities, and respective characteristics. Moreover, based on these explorations, we analyse their advantages from the aspects of failure detection and fault understanding. During the analysis, a symbolic-graphic combination method is applied. Finally simulation based on real-life programs is conducted to observe our analysis. Our comparison analysis can support the selection of a proper testing approach according to various practical environments with different targets. Furthermore, the clarification of the two easily confused concepts is also a complement for the framework of Adaptive Testing and Software Cybernetics.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7978795,yes,
683,Cost aware test suite reduction algorithm for regression testing,"Regression testing is the process that a recent code change has not adversely affect the existing features. The re-running of all the test cases during regression testing is very expensive as it requires huge time and resources. Test case prioritization techniques are to schedule the test cases in accordance with some criteria such that important test cases are executed with that given period. This study presents test case prioritization using genetic algorithm and their effectiveness is measured using APFD. Then the prioritized test cases are reduced. Test suite reduction techniques aim at identifying and eliminating redundant test cases from test suites in order to reduce the total number of test cases to execute, thereby improving the efficiency of the software testing activity. Our aim is to reduce the cost by reducing the number of test suite after prioritization. MFTS algorithm is used to reduce the given test suite with maximum coverage and it improves the rate of fault detection effectiveness.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8300829,yes,
684,Cost-Effective Regression Testing Using Bloom Filters in Continuous Integration Development Environments,"Regression testing in continuous integration development environments must be cost-effective and should provide fast feedback on test suite failures to the developers. In order to provide faster feedback on failures to developers while using computing resources efficiently, two types of regression testing techniques have been developed: Regression Testing Selection (RTS) and Test Case Prioritization (TCP). One of the factors that reduces the effectiveness of the RTS and TCP techniques is the inclusion of test suites that fail only once over a period. We propose an approach based on Bloom filtering to exclude such test suites during the RTS process, and to assign such test suites with a lower priority during the TCP process. We experimentally evaluate our approach using a Google dataset, and demonstrate that cost-effectiveness of the proposed RTS and TCP techniques outperforms the state-of-the-art techniques.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8305938,no,
685,Coverage-Based Reduction of Test Execution Time: Lessons from a Very Large Industrial Project,"There exist several coverage-based approaches to reduce time and resource costs of test execution. While these methods are well-investigated and evaluated for smaller to medium-size projects, we faced several challenges in applying them in the context of a very large industrial software project, namely SAP HANA. These issues include: varying effectiveness of algorithms for test case selection/prioritization, large amounts of shared (non-specific) coverage between different tests, high redundancy of coverage data, and randomness of test results (i.e. flaky tests), as well as of the coverage data (e.g. due to concurrency issues). We address these issues by several approaches. First, our study shows that compared to standard algorithms, so-called overlap-aware solvers can achieve up to 50% higher code coverage in a fixed time budget, significantly increasing the effectiveness of test case prioritization and selection. We also detected in our project high redundancy of line coverage data (up to 97%), providing opportunities for data size reduction. Finally, we show that removal of coverage shared by tests can significantly increase test specificity. Our analysis and approaches can help to narrow the gap between research and practice in context of coverage-based testing approaches, especially in case of very large software projects.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7899023,no,
686,d(mu)Reg: A Path-Aware Mutation Analysis Guided Approach to Regression Testing,"Regression testing re-runs some previously executed test cases, with the purpose of checking whether previously fixed faults have re-emerged and ensuring that the changes do not negatively affect the existing behaviors of the software under development. Today's software is rapidly developed and evolved, and thus it is critical to implement regression testing quickly and effectively. In this paper, we propose a novel technique for regression testing, based on a family of mutant selection strategies. The preliminary results show that the proposed technique can significantly improve the efficiency of different regression testing activities, including test case reduction and prioritization. Our work also makes it possible to develop a unified framework that effectively implements various activities in regression testing.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7962333,no,
687,Delta-Oriented Product Prioritization for Similarity-Based Product-Line Testing,"Testing every product of a software product line (SPL) is often not feasible due to the exponential number of products in the number of features. Thus, the order in which products are tested matters, because it can increase the early rate of fault detection. Several approaches have been proposed to prioritize products based on configuration similarity. However, current approaches are oblivious to solution-space differences among products, because they consider only problem-space information. With delta modeling, we incorporate solution-space information in product prioritization to improve the effectiveness of SPL testing. Deltas capture the differences between products facilitating the reasoning about product similarity. As a result, we select the most dissimilar product to the previously tested ones, in terms of deltas, to be tested next. We evaluate the effectiveness of our approach using an SPL from the automotive domain showing an improvement in the effectiveness of SPL testing.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7968061,no,
688,Deriving high-priority acceptance test cases using utility trees: A case study,"Even though software testing is considered a mature field in software engineering, deriving test cases is still an important issue and even more when related to quality requirements. Utility Trees are used to evaluate software architectures, organizing requirements as scenarios associated to quality attributes and decorating them with stakeholder-given priority and developer- given difficulty. In this article, we propose an approach to use Utility Trees to derive prioritized acceptance test cases allowing to focus in high-value tests. The technique has been tried in two medium-sized projects for a Chilean public agency, with positive results. This innovative use of Utility Trees offers a simple, collaborative way to focus testing resources.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8405142,no,
689,Design and Implementation of Combinatorial Testing Tools,"As an effective software testing technique, combinatorial testing has been gradually applied in various types of test practice. In this case, it is necessary to provide useful combinatorial testing tools to support the application of combinatorial testing technique on industrial scenarios, as well as the academic research for combinatorial testing technique. To this end, on the basis of the research results of this group, a suite of combinatorial testing tools has been developed, whose functions include test case generation, test case optimization, and etc. For the requirements from both industrial and academic scenarios, the tools should be configurable, scalable, modular, and etc. This paper gives a brief introduction to the design and implementation of these tools. Keywords-combinatorial testing, combinatorial testing tools, test generation, test prioritization.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8004338,yes,
690,Digital learning as a tool to overcome school failure in minority groups,"In the European Union development strategy formulated in the Europe 2020 document (European Commission, 2015) it was indicated, that the smart growth of the EU as a whole should be reached through the realization of three priorities: the increase in employment, the increase of productiveness and the social cohesion and specialized agendas: Digital Agenda, Education and Learning, E-skills and Employment. The main documents identify main weaknesses and risk areas. One of the most significant was described as the early school leaving of Roma minority members. Roma constitute Europe's largest transnational ethnic minority with an estimate of ten million people. Learning outcomes of this minority are significantly lower than outcomes of the majority. As one of the reasons for early school leaving of Roma, insufficient understanding of learning materials is identified. The result is that most of the Roma community members drop out of education before attending a secondary school and continue their lives as unemployed or enter the labor market as unskilled workers. Within the paper will be presented the CloudLearning project that represents an alternative and innovative educational method: the way of the SOLE method implemented in their education. This paper will include partial results from the pilot tests realized these days.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7973525,no,
691,Educational prototype demonstrating frequency spectrum sharing through channel borrowing and priority assignment,"The purpose of this research is to build an educational prototype for attracting high school seniors and college students to pursue university degrees. The prototype entails demonstrable hardware and software comprising of a set of communication nodes with call priorities, which are used to help educate students on future and practical implications of spectrum sharing. Two objectives are achieved by building this hands-on prototype: (1) Students learn firsthand basics of communication systems and (2) Students are taught the concept and feasibility of ƒ??priorityƒ? in RF device communication. In crafting this easy-to-use prototype, integrated Arduinos, RF modules, and open-source libraries are utilized. Eight simplex devices (or nodes) that can communicate over just three channels in the 2.4GHz ISM band are built to articulate the spectrum scarcity challenge. When placing a call, a device requests a channel from the base station, which notifies the device about available channels, taking into account both device priorities (e.g. some devices have higher priorities) and channels that are in use by other calls. The base station has the authority to remove devices from a channel or transfer them to another channel when necessary. The paradigm of ƒ??priority assignmentƒ? is implemented keeping in mind futuristic trends in communication systems aimed at optimal use of the transmission spectrum. The prototype is validated via many test cases.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8053422,no,
692,Efficient Product-Line Testing Using Cluster-Based Product Prioritization,"A software product-line comprises a set of products that share a common set of features. These features can be reused to customize a product to satisfy specific needs of certain customers or markets. As the number of possible products increases exponentially for new features, testing all products is infeasible. Existing testing approaches reduce their effort by restricting the number of products (sampling) and improve their effectiveness by considering the order of tests (prioritization). In this paper, we propose a cluster-based prioritization technique to sample similar products with respect to the feature selection. We evaluate our approach using feature models of different sizes and show that cluster-based prioritization can enhance the effectiveness of product-line testing.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7962326,no,
693,Enabling Software Defined Networking with QoS Guarantee for Cloud Applications,"Due to the centralized control, network-wide monitoring and flow-level scheduling of Software-Defined-Networking (SDN), it can be utilized to achieve Quality of Service (QoS) for cloud applications and services, such as voice over IP, video conference and online games, etc. However, most existing approaches stay at the QoS framework design and test level, while few works focus on studying the basic QoS techniques supported by SDN. In this paper, we enable SDN with QoS guaranteed abilities, which could provide end-to-end QoS routing for each cloud user service. First of all, we implement an application identification technique on SDN controller to determine required QoS levels for each application type. Then, we implement a queue scheduling technique on SDN switch. It queues the application flows into different queues and schedules the flows out of the queues with different priorities. At last, we evaluate the effectiveness of the proposed SDN-based QoS technique through an experimental analysis. Results show that when the output interface has sufficiently available bandwidth, the delay can be reduced by 28% on average. In addition, for the application flow with the highest priority, our methods can reduce 99.99% delay and increase 90.17% throughput on average when the output interface utilization approaches to the maximum bandwidth limitation.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8030581,no,
694,Epistasis Based ACO for Regression Test Case Prioritization,"Metaheuristics that are inspired by natural systems have been widely applied into search-based software engineering. It has been shown that combining knowledge of the application domain with a biological theory for metaheuristics can narrow down the search space and speed up the convergence for metaheuristics based algorithms. This paper introduces Epistatic Test case Segment (ETS) for multiobjective search-based regression Test Case Prioritization (MoTCP), based on epistasis theory that reflects the correlation between genes in evolution process. An ETS-based pheromone update strategy for ant colony optimization (ACO) algorithm is proposed. The experiments with three benchmarks and a real industrial program V8 illustrate that proposed pheromone update strategy guided by the epistasis theory can significant improve the performance of ACO in terms of effectiveness and efficiency for search-based MoTCP.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7935487,no,
695,Evaluation of AV systems against modern malware,"Countering the proliferation of malware has been for recent years one of the top priorities for governments, businesses, critical infrastructure, and end users. Despite the apparent evolvement of anti-virus (AV) systems, malicious authors have managed to create a sense of insecurity amongst computer users. Security controls do not appear to be sufficiently strong to stop malware proliferating. There seems to be a disconnect between public reports on AV tests and what people are experiencing on the daily basis. In this research, we are testing the efficiency of AV products and their ability to detect malicious files commonly known as malware. We manually generated payloads from five malware frameworks freely available to download and use. We use two modes of tests during our experiments. We manually installed a selection of AV systems in one first instance. We also use an online framework for testing malicious files. The findings in this study show that many antivirus systems were not able to achieve a higher score than 80% detection rate. Certain attack frameworks were much more successful in generating payloads that were not detectable by AV systems. We conclude that AV systems have their roles to play as they are the most common first line of defense, but more work is needed to successfully detect most malware the first day of their release.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8356397,no,
696,Exniffer: Learning to Prioritize Crashes by Assessing the Exploitability from Memory Dump,"An important component of software reliability is the assurance of certain security guarantees, such as absence of low-level bugs that may result in code exploitation, for example. A program crash is an early indicator of possible errors in the program like memory corruption, access violation or division by zero. In particular, a crash may indicate the presence of safety or security critical errors. A safety-error crash does not result in any exploitable condition, whereas a security-error crash allows an attacker to exploit a vulnerability. However, distinguishing one from the other is a non-trivial task. This exacerbates the problem in cases where we get hundreds of crashes and programmers have to make choices which crash to patch first! In this work, we present a technique to identify security critical crashes by applying machine learning on a set of features derived from core-dump files and runtime information obtained from hardware assisted monitoring such as the last branch record (LBR) register. We implement the proposed technique in a prototype called Exniffer. Our empirical results, obtained by experimenting Exniffer on several crashes on real-world applications show that proposed technique is able to classify a given crash as exploitable or not-exploitable with high accuracy.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8305946,no,
697,Extravehicular activity operations concepts under communication latency and bandwidth constraints,"The Biologic Analog Science Associated with Lava Terrains (BASALT) project is a multi-year program dedicated to iteratively develop, implement, and evaluate concepts of operations (ConOps) and supporting capabilities intended to enable and enhance human scientific exploration of Mars. This paper describes the planning, execution, and initial results from the first field deployment, referred to as BASALT-1, which consisted of a series of ten simulated extravehicular activities on volcanic flows in Idaho's Craters of the Moon National Monument and Preserve. The ConOps and capabilities deployed and tested during BASALT-1 were based on previous NASA trade studies and analog testing. Our primary research question was whether those ConOps and capabilities work acceptably when performing real (non-simulated) biological and geological scientific exploration under four different Mars-to-Earth communication conditions: 5 and 15 min one-way light time communication latencies and low (0.512 Mb/s uplink, 1.54 Mb/s downlink) and high (5.0 Mb/s uplink, 10.0 Mb/s downlink) bandwidth conditions, which represent two alternative technical communication capabilities currently proposed for future human exploration missions. The synthesized results, based on objective and subjective measures, from BASALT-1 established preliminary findings that the baseline ConOp, software systems, and communication protocols were scientifically and operationally acceptable with minor improvements desired by the ƒ??Marsƒ? extravehicular and intravehicular crewmembers. However, unacceptable components of the ConOps and required improvements were identified by the ƒ??Earthƒ? Mission Support Center. These data provide a basis for guiding and prioritizing capability development for future BASALT deployments and, ultimately, future human exploration missions.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7943570,no,
698,Flow Reconnaissance via Timing Attacks on SDN Switches,"When encountering a packet for which it has no matching forwarding rule, a software-defined networking (SDN) switch requests an appropriate rule from its controller; this request delays the routing of the flow until the controller responds. We show that this delay gives rise to a timing side channel in which an attacker can test for the recent occurrence of a target flow by judiciously probing the switch with forged flows and using the delays they encounter to discern whether covering rules were previously installed in the switch. We develop a Markov model of an SDN switch to permit the attacker to select the best probe (or probes) to infer whether a target flow has recently occurred. Our model captures practical challenges related to rule evictions to make room for other rules; rule timeouts due to inactivity; the presence of multiple rules that apply to overlapping sets of flows; and rule priorities. We show that our model enables detection of target flows with considerable accuracy in many cases.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7979967,no,
699,Formal Methods for Validation and Test Point Prioritization in Railway Signaling Logic,"The EN50128 Railway Safety Standard recommends the use of formal methods for proving the correctness of the yard-specific logic, which was developed for electronic signaling and interlocking systems. We present a tool flow, which consists of three components. The core component uses a novel method for automatically generating the relevant safety properties for a yard from its control table. The second component proves the validity of the properties on the application logic by using a new theory of invariant checking. The third component leverages the suite of formal properties to prioritize site acceptance test points. Experimental results are presented on real application data for the yards in India that are demonstrating the performance of the proposed methods.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7529152,no,
700,Game Theoretic Study on Channel-Based Authentication in MIMO Systems,"In this paper, we investigate the authentication based on radio channel information in multiple-input multiple-output (MIMO) systems and formulate the interactions between a receiver with multiple antennas and a spoofing node as a zero-sum physical (PHY)-layer authentication game. In this game, the receiver chooses the test threshold of the hypothesis test to maximize its Bayesian risk-based utility in the spoofing detection, while the adversary chooses its attack rate, i.e., how often a spoofing signal is sent. We derive the Nash equilibrium (NE) of the static PHY-layer authentication game and present the condition that the NE exists, showing that both the spoofing detection error rates and the spoofing rate decrease with the number of transmit and receive antennas. We propose a PHY-layer spoofing detection algorithm for MIMO systems based on Q-learning, in which the receiver applies the reinforcement learning technique to achieve the optimal test threshold via trials in a dynamic game without knowing the system parameters, such as the channel time variation and spoofing cost. We also use Dyna architecture and prioritized sweeping (Dyna-PS) to improve the spoofing detection in time-variant radio environments. The proposed authentication algorithms are implemented over universal software radio peripherals and evaluated via experiments in an indoor environment. Experimental results show that the Dyna-PS-based spoofing detection algorithm further reduces the spoofing detection error rates and increases the utility of the receiver compared with the Q-learning-based algorithm, and both performances improve with more number of transmit or receive antennas.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7815442,no,
701,Gamifying Collaborative Prioritization: Does Pointsification Work?,"Gamification has been applied in software engineering contexts, and more recently in requirements engineering with the purpose of improving the motivation and engagement of people performing specific engineering tasks. But often an objective evaluation that the resulting gamified tasks successfully meet the intended goal is missing. On the other hand, current practices in designing gamified processes seem to rest on a try, test and learn approach, rather than on first principles design methods. Thus empirical evaluation should play an even more important role.We combined gamification and automated reasoning techniques to support collaborative requirements prioritization in software evolution. A first prototype has been evaluated in the context of three industrial use cases. To further investigate the impact of specific game elements, namely point-based elements, we performed a quasi-experiment comparing two versions of the tool, with and without pointsification. We present the results from these two empirical evaluations, and discuss lessons learned.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8049138,no,
702,Impact of Static and Dynamic Coverage on Test-Case Prioritization: An Empirical Study,"Most of existing research in Test-Case Prioritization uses coverage information as the input during the process of prioritization and these coverage can be classified into two categories: static coverage and dynamic coverage. As these coverage information are collected in different ways, they have different influence on test-case prioritization. In this work, we present the first empirical study comparing the impact of static coverage and dynamic coverage with five typical techniques at different test-case granularities (e.g., test-method and test-class level) and different coverage criteria (e.g., method and statement coverage). This study is performed on 15 real-world Java projects (using 163 versions) and we find that the dynamic coverage performs better than static coverage in terms of the results of test-case prioritization.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7899091,yes,
703,Improving test case prioritization based on practical priority factors,"Test case prioritization involves prioritized the test cases for regression testing which improve the effectiveness of the testing process. By improving test case scheduling we can optimize time and cost as well as can produce better tested products. There are a number of methods to do prioritized test cases but not that effective or practical for the real-life large commercial systems. Most of the technique deals with finding defects or covering more test cases. In this paper, we will extend the previous work to incorporate real life practical aspects to schedule test cases. This will cover most of the businesses functionally based on the practical aspects. This approach covers more business area and ensure more defects. By prioritized test cases with this technique we will cover most important business functionally with less number of test cases.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8343055,yes,
704,Improving the Cooperation of Fuzzing and Symbolic Execution by Test-cases Prioritizing,"Nowadays much attention is paid to the threat of vulnerabilities on the software security. Fuzzing and symbolic execution, complementary to each other, are two effective techniques in software testing. In this paper, we develop the prototype called FAS(Fuzzing and Symbolic) for software testing under both fuzzing and symbolic execution. In our method, the test cases are prioritized through deep-oriented strategy and large-distance-first strategy, in order to get a higher path-coverage with the condition of limited resource.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8288548,no,
705,Knowledge Transfer for Global Roles in GSE,"This practice paper presents how a software engineering organization spread across three countries successfully transferred the knowledge of a few identified roles for a large mission-critical software system that had to conform to regulatory requirements. Multiple releases of the system have been delivered to customers over the 15 years it has been in the market. Each release of the product had a focus area. The competence availability for these focus areas was distributed. As a natural evolution of the globally distributed team, greater responsibility is devolved to a particular location, based on the availability of the competence at that location. Moving the increased responsibility to a location, created a global role, which did not exist earlier. Building the new role required a new skill, what is unique about a global role. Equipping the team members in the new skill was necessary to take up the roles effectively and quickly. The first step was the identification of the competence for a function/role, training for which may be imparted to another person, who will take over the function/role. This is followed by a process of knowledge transfer, which ensured that a person can take up a new global role from another location. Prioritization based on ease of knowledge transfer for different areas of work, that was found to be effective is described. This helped reduce possible problems that could occur due to incorrect or incomplete transfer of knowledge. The advantages by such knowledge transfer that resulted in new persons taking up global roles have outweighed its disadvantages. The practices described are generic and can be applied to any organization of similar size and complexity.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7976692,no,
706,Learning to Predict Severity of Software Vulnerability Using Only Vulnerability Description,"Software vulnerabilities pose significant security risks to the host computing system. Faced with continuous disclosure of software vulnerabilities, system administrators must prioritize their efforts, triaging the most critical vulnerabilities to address first. Many vulnerability scoring systems have been proposed, but they all require expert knowledge to determine intricate vulnerability metrics. In this paper, we propose a deep learning approach to predict multi-class severity level of software vulnerability using only vulnerability description. Compared with intricate vulnerability metrics, vulnerability description is the ""surface level"" information about how a vulnerability works. To exploit vulnerability description for predicting vulnerability severity, discriminative features of vulnerability description have to be defined. This is a challenging task due to the diversity of software vulnerabilities and the richness of vulnerability descriptions. Instead of relying on manual feature engineering, our approach uses word embeddings and a one-layer shallow Convolutional Neural Network (CNN) to automatically capture discriminative word and sentence features of vulnerability descriptions for predicting vulnerability severity. We exploit large amounts of vulnerability data from the Common Vulnerabilities and Exposures (CVE) database to train and test our approach.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8094415,no,
707,Learning to Prioritize Test Programs for Compiler Testing,"Compiler testing is a crucial way of guaranteeing the reliability of compilers (and software systems in general). Many techniques have been proposed to facilitate automated compiler testing. These techniques rely on a large number of test programs (which are test inputs of compilers) generated by some test-generation tools (e.g., CSmith). However, these compiler testing techniques have serious efficiency problems as they usually take a long period of time to find compiler bugs. To accelerate compiler testing, it is desirable to prioritize the generated test programs so that the test programs that are more likely to trigger compiler bugs are executed earlier. In this paper, we propose the idea of learning to test, which learns the characteristics of bug-revealing test programs from previous test programs that triggered bugs. Based on the idea of learning to test, we propose LET, an approach to prioritizing test programs for compiler testing acceleration. LET consists of a learning process and a scheduling process. In the learning process, LET identifies a set of features of test programs, trains a capability model to predict the probability of a new test program for triggering compiler bugs and a time model to predict the execution time of a test program. In the scheduling process, LET prioritizes new test programs according to their bug-revealing probabilities in unit time, which is calculated based on the two trained models. Our extensive experiments show that LET significantly accelerates compiler testing. In particular, LET reduces more than 50% of the testing time in 24.64% of the cases, and reduces between 25% and 50% of the testing time in 36.23% of the cases.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985706,no,
708,On a Pursuit for Perfecting an Undergraduate Requirements Engineering Course,"Requirements Engineering (RE) is an essential component of any software development cycle. Understanding and satisfying stakeholder needs and wants is the difference between the success and failure of a product. However, RE is often perceived as a ""soft"" skill by our students and is often ignored by students who prioritize the learning of coding, testing, and algorithmic thinking. This view contrasts with the industry, where ""soft"" skills are instead valued equal to any other engineering ability. A key challenge in teaching RE is that students who are accustomed to technical work have a hard time relating to something that is non-technical. Furthermore, students are rarely afforded the opportunity to practice requirements elicitation and management skills in a meaningful way while learning the RE concepts as an adjunct to other content. At Rose-Hulman, we have experimented with several project-based approaches to teaching RE, which have evolved over time. In this paper, we document the progress of our teaching methodologies, capture the pros and cons of these varied approaches, and reflect on what worked and what did not in teaching RE to undergraduate engineering students.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8166688,no,
709,Performance analysis of OSPF and hybrid networks,"Software Defined Network (SDN) for large-scale IP provider network is an open issue and different solutions were proposed. However, the hybrid IP networks in which both distributed and centralized approach provide centralization of SDN and reliability of distributed networks. The common approach in which SDN controls the prioritized traffic and OSPF (Open Shortest Path First) guarantees the operation of traffic. In this research, we propose the SDN segregation, which maintain central management over dispersed routing control. A given topology is split in some fields with OpenFlow enabled switches as in between nodes. OSPF enabled router triggered updates to other routers in other field via SDN switches. The centralized controller defines how two OSPF routers observe each other. There will be a tradeoff between central control of SDN and fault tolerance capability of OSPF. As we increase SDN nodes control will increase and fault tolerance capacity of overall network decreases. The novelty of research work for balanced topology segregation also offers the models for network management. To show the enhancement provided by hybrid network over routing protocol deployment we have deployed separate test beds for routing protocol and proposed hybrid network.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8250022,no,
710,Petri net based software testing scheduling and selecting,Computer software system has a profound impact on human society. It increasingly highlights the importance of software testing. Reducing the cost and improving the efficiency of software testing has an important practical significance and economic value. This paper investigates on software testing workflow from the perspective of discrete event dynamic systems and presents a method to improve the efficiency of software testing by optimizing task scheduling and execution priorities. We developed a simulation program of task scheduling based on Petri net to compare the performance of each scheduling option in different situations and made the analysis of their differences.,2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8000086,no,
711,Predicting Fault-Prone Classes in Object-Oriented Software: An Adaptation of an Unsupervised Hybrid SOM Algorithm,"Many fault-proneness prediction models have been proposed in literature to identify fault-prone code in software systems. Most of the approaches use fault data history and supervised learning algorithms to build these models. However, since fault data history is not always available, some approaches also suggest using semi-supervised or unsupervised fault-proneness prediction models. The HySOM model, proposed in literature, uses function-level source code metrics to predict fault-prone functions in software systems, without using any fault data. In this paper, we adapt the HySOM approach for object-oriented software systems to predict fault-prone code at class-level granularity using object-oriented source code metrics. This adaptation makes it easier to prioritize the efforts of the testing team as unit tests are often written for classes in object-oriented software systems, and not for methods. Our adaptation also generalizes one main element of the HySOM model, which is the calculation of the source code metrics threshold values. We conducted an empirical study using 12 public datasets. Results show that the adaptation of the HySOM model for class-level fault-proneness prediction improves the consistency and the performance of the model. We additionally compared the performance of the adapted model to supervised approaches based on the Naive Bayes Network, ANN and Random Forest algorithms.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8009935,no,
712,PV-OWL ƒ?? Pharmacovigilance surveillance through semantic web-based platform for continuous and integrated monitoring of drug-related adverse effects in open data sources and social media,"The recent EU regulation on Pharmacovigilance [Regulation (EU) 1235/2010, Directive 2010/84/EU] imposes both to Pharmaceutical companies and Public health agencies to maintain updated safety information of drugs, monitoring all available data sources. Here, we present our project aiming to develop a web platform for continuous monitoring of adverse effects of medicines (pharmacovigilance), by integrating information from public databases, scientific literature and social media. The project will start by scanning all available data sources concerning drug adverse events, both open (e.g., FAERS - FDA Adverse Event Reporting Systems, medical literature, social media, etc.) and proprietary data (e.g., discharge hospital records, drug prescription archives, electronic health records), that require agreement with respective data owners. Subsequent, pharmacovigilance experts will perform a semi-automatic mapping of codes identifying drugs and adverse events, to build the thesaurus of the web based platform. After these preliminary activities, signal generation and prioritization will be the core of the project. This task will result in risk confidence scores for each included data source and a comprehensive global score, indicating the possible association between a specific drug and an adverse event. The software framework MOMIS, an open source data integration system, will allow semi-automatic virtual integration of heterogeneous and distributed data sources. A web platform, based on MOMIS, able to merge many heterogeneous data sets concerning adverse events will be developed. The platform will be tested by external specialized subjects (clinical researchers, public or private employees in pharmacovigilance field). The project will provide a) an innovative way to link, for the first time in Italy, different databases to obtain novel safety indicators; b) a web platform for a fast and easy integration of all available data, useful to verify and validate hypothesis generated in signal detection. Finally, the development of the unified safety indicator (global risk score) will result in a compelling, easy-to-understand, visual format for a broad range of professional and not professional users like patients, regulatory authorities, clinicians, lawyers, human scientists.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8065931,no,
713,QoS-based routing over software defined networks,"Quality of Service (QoS) relies on the shaping of preferential delivery services for applications in favour of ensuring sufficient bandwidth, controlling latency and reducing packet loss. QoS can be achieved by prioritizing important broadband data traffic over the less important one. Thus, depending on the users' needs, video, voice or data traffic take different priority based on the prevalent importance within a particular context. This prioritization might require changes in the configuration of each network entity which can be difficult in traditional network architecture. To this extent, this paper investigates the use of a QoS-based routing scheme over a Software Defined Network (SDN). A real SDN test-bed is constructed using Raspberry Pi computers as virtual SDN switches managed by a centralized controller. It is shown that a QoS-based routing approach over SDN generates enormous control possibilities and enables automation.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7986239,no,
714,Ranking Modules for Integrate Testing Based on PageRank Algorithm,"The testing industry need to prioritize the limited resources and focus on testing modules whose failure is mostly likely to cause faults. This paper discusses a method that can rank modules in a software package for integrate testing using the PageRank algorithm. In this algorithm, a sequences of random walks iteratively can find a high likelihood of encountering a node, which is interpreted as it being an important performance resource. An experiment result prove that the proposed method actually can be used to prioritize testing of specific modules when testing resource are scarce.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8055343,no,
715,Regression Testing Goals - View of Practitioners and Researchers,"Context: Regression testing is a well-researched area. However, the majority regression testing techniques proposed by the researchers are not getting the attention of the practitioners. Communication gaps between industry and academia, and disparity in the regression testing goals are the main reasons. Close collaboration can help in bridging the communication gaps and resolving the disparities. Objective: The study aims at exploring the views of academics and practitioners about the goals of regression testing. The purpose is to investigate the commonalities and differences in their viewpoints and defining some common goals for the success of regression testing. Method: We conducted a focus group study, with 7 testing experts from industry and academia. 4 testing practitioners from 2 companies and 3 researchers from 2 universities participated in the study. We followed GQM approach, to elicit the regression testing goals, information needs, and measures. Results: 43 regression testing goals were identified by the participants, which were reduced to 10 on the basis of similarity among the identified goals. Later during the priority assignment process, 5 goals were discarded, because the priority assigned to these goals was very low. Participants identified 47 information needs/questions required to evaluate the success of regression testing with reference to goal G5 (confidence). Which were then reduced to 10 on the basis of similarity. Finally, we identified measures to gauge those information needs/questions, which were corresponding to the goal (G5). Conclusions: We observed that participation level of practitioners and researchers during the elicitation of goals and questions was same. We found a certain level of agreement between the participants regarding the regression testing definitions and goals. But there was some level of disagreement regarding the priorities of the goals. We also identified the need to implement a regression testing evaluation framework in the participating companies.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8312521,no,
716,Regression Testing of Database Applications Under an Incremental Software Development Setting,"Software regression testing verifies previous features on a software product when it is modified or new features are added to it. Because of the nature of regression testing it is a costly process. Different approaches have been proposed to reduce the costs of this activity, among which are: minimization, prioritization, and selection of test cases. Recently, soft computing techniques, such as data mining, machine learning, and others have been used to make regression testing more efficient and effective. Currently, in different contexts, to a greater or lesser extent, software products have access to databases (DBs). Given this situation, it is necessary to consider regression testing also for software products such as information systems that are usually integrated with or connected to DBs. In this paper, we present a selection regression testing approach that utilizes a combination of unsupervised clustering with random values, unit tests, and the DB schema to determine the test cases related to modifications or new features added to software products connected to DBs. Our proposed approach is empirically evaluated with two database software applications in a production context. Effectiveness metrics, such as test suite reduction, fault detection capability, recall, precision, and the F-measure are examined. Our results suggest that the proposed approach is enough effective with the resulting clusters of test cases.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8027014,no,
717,Requirement dependencies-based formal approach for test case prioritization in regression testing,"Regression testing is the testing activity performed after changes occurred on software. Its aim is to increase confidence that achieved software adjustments have no negative impact on the already functional parts of the software. Test case prioritization is one technique that could be applied in regression testing with the aim to find faults early, resulting in reduced cost and shorten time of testing activities. Thus, prioritizing in the context of regression testing means to re-order test cases such that high priority ones are run first. The current paper addresses the test case prioritization as a consistent part of a larger approach on regression testing, which combines both test case prioritization and test case selection in order to overcome the limitations of each of them. A comprehensive formalization of test case prioritization is provided, incorporating beside the well known ingredients (test case, test requirement, fault, cost) also elements relating to the functional requirements and dependencies between requirements. An evolutionary algorithm is used to construct the re-ordering of test cases, considering as optimization objectives fault detection and cost. A synthetic case study was used to empirically prove our perspective for test case prioritization approach.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8117002,yes,
718,Requirement paramerisation of flap actuation system: Product life-cycle management processes &amp; tools,"Flap actuation systems (FAS) have numerous operational states, modes and environmental constraints, which translate to thousands of requirements associated with them. FAS must be analyzed and tested to determine compliance with requirements in any operating conditions. In this paper, examples of parametrized requirements for centrally driven FAS are presented and the advantages brought by a requirement parametrization process in the systems engineering life- cycle discussed, from requirements elicitation to requirements validation and verification. The challenges of robust re-use and customization of components within legacy systems to drive cost reduction is significant as often legacy products were not developed within a model base framework. The requirements prioritization process provides a low cost, high impact example of alternative to ensure integrity and full traceability of requirements without the need to implement complex simulation platforms.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8088317,no,
719,Risk-based attack surface approximation: how much data is enough?,"Proactive security reviews and test efforts are a necessary component of the software development lifecycle. Resource limitations often preclude reviewing the entire code base. Making informed decisions on what code to review can improve a team's ability to find and remove vulnerabilities. Risk-based attack surface approximation (RASA) is a technique that uses crash dump stack traces to predict what code may contain exploitable vulnerabilities. The goal of this research is to help software development teams prioritize security efforts by the efficient development of a risk-based attack surface approximation. We explore the use of RASA using Mozilla Firefox and Microsoft Windows stack traces from crash dumps. We create RASA at the file level for Firefox, in which the 15.8% of the files that were part of the approximation contained 73.6% of the vulnerabilities seen for the product. We also explore the effect of random sampling of crashes on the approximation, as it may be impractical for organizations to store and process every crash received. We find that 10-fold random sampling of crashes at a rate of 10% resulted in 3% less vulnerabilities identified than using the entire set of stack traces for Mozilla Firefox. Sampling crashes in Windows 8.1 at a rate of 40% resulted in insignificant differences in vulnerability and file coverage as compared to a rate of 100%.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7965451,no,
720,Studies on open source real time operating systems: For vehicle suspension control,"Studying the TIMELINESS of PERIODIC tasks of real time operating systems available in open source, to determine the reliability and efficiency of the systems for implementing them in suspension control of ground vehicles. We take several operating systems which are open source and are available to the public through GNU license (ex: Linux). The Kernels, which are the building blocks of the operating systems which connect hardware and software, are patched using selective real time patches which makes the operating system real time. This is done in order to unlock real time capabilities such as unbounded latencies and real time priorities. These operating systems are tested for their efficiency and timeliness. The results are compared with the test logs of non-real time operating system. These kernels are then cross compiled and built for ARM architecture. This kernel is then applied to an embedded system which is then tested using the same afore mentioned tests. The results are logged and analyzed.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8070787,no,
721,Table of contents,The following topics are dealt with: software design; mutation testing; collective online testing; collective offline testing; usability tests; Web services; delta-oriented programming; delta-oriented product prioritization and feature models.,2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7968031,no,
722,Test Case Generation and Prioritization: A Process-Mining Approach,"Test cases are an essential tool in software quality assurance: they ensure that code behaves as specified in the requirement. However, writing test cases does not have only benefits, it comes with a cost: the programmer has to formulate the test cases and maintain them when the tested source code changes. Particularly for start-ups or small enterprises such costs become prohibitive, which often prefer to invest their time into the development of new functionalities instead of testing. This paper explores the use of process-mining as an approach to create a model of how users interact with a system to a) generate test cases and b) prioritize them. Using process-mining, it is possible to mine from the user behaviour which parts of the system are the most used, in which order they are executed, generate test cases repeating user input, and prioritizing test cases.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7899028,yes,
723,Test Optimization from Release Insights: An Analytical Hierarchy Approach,"Software Testing is an essential aspect to ensure software quality, reliability and consistent user experience. Digital applications such as mobile app usually follow rapid software delivery which consists of various releases. It typically uses insights from the development data such as defects, test logs for test execution optimization. Once the application is released and deployed, there is rich availability of untapped heterogeneous data which can also be effectively utilized for the next release test execution optimization. The data from the release includes direct customer feedback, application monitoring data such as user behavioral traces, device usages, release logs. In this position paper, we discuss about the various data sources and the multiple insights which can be derived from them. We also propose a framework which uses Analytical Hierarchy Process to prioritize the tests based on these insights available from the release data. The framework also recommends the prioritized and missed device configurations for next release test planning.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7967947,no,
724,Test Prioritization with Optimally Balanced Configuration Coverage,"Testing configurable software for high assurancesystems developed in continuous integration requires effectivetechniques for selecting failure-inducing test cases, thoroughlycovering entire configuration space, while providing rapid feedbackon failures. This involves satisfying multiple objectives:maximizing test fault detection, maximizing test coverage ofthe configuration space, and minimizing test execution time, which often leads to compromises in practice. In this paper, weaddress this problem with a practical test optimization approachthat uses historical test data to determine an optimal order oftests ensuring high progressively uniform configuration coverage, early fault detection, and rapid test feedback. We extensivelyvalidate the approach in a set of experiments using industry testsuites, and report experimental results showing the improvementin efficiency compared to industry practice. In particular, theapproach showed to increase the uniformity of configurationcoverage by 39% on average, which increases fault detectionup to 15%, while just slightly delaying test feedback.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7911878,yes,
725,Test Suite Prioritization for Efficient Regression Testing of Model-Based Automotive Software,"Up to 80% of the automotive software can be generated from models. MATLAB Simulink is a common tool for creation of complex combinations of block diagrams and state machines, automated generation of executable code, and its deployment on a target ECU. The automotive safety standards require extensive testing of the developed models. Regression testing should be undertaken every time a model is updated to ensure that the modifications do not introduce new faults into the previously validated model. A common, time-consuming way is to rerun an entire test suite after even minor changes. This paper introduces a new method for automatic prioritization of test cases. The method is based on two principles: (i) A test case should stimulate an error in an updated block and (ii) the stimulated error should propagate to the place where it can be detected. The proposed method includes the evaluation of input vectors that are provided to updated blocks by each test case and a Markov-based stochastic error propagation analysis of the model. The application of the method is demonstrated with a Simulink model of a gearbox and a test-suite, automatically generated with the Reactis Tester.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8118517,yes,
726,The organization of arrangements set to ensure enterprise IPV6 network secure work by modern switching equipment tools (using the example of a network attack on a default gateway),"The article issue is the enterprise information protection within the internet of things concept. The aim of research is to develop arrangements set to ensure secure enterprise IPv6 network operating. The object of research is the enterprise IPv6 network. The subject of research is modern switching equipment as a tool to ensure network protection. The research task is to prioritize functioning of switches in production and corporation enterprise networks, to develop a network host protection algorithm, to test the developed algorithm on the Cisco Packet Tracer 7 software emulator. The result of research is the proposed approach to IPv6-network security based on analysis of modern switches functionality, developed and tested enterprise network host protection algorithm under IPv6-protocol with an automated network SLAAC-configuration control, a set of arrangements for resisting default enterprise gateway attacks, using ACL, VLAN, SEND, RA Guard security technology, which allows creating sufficiently high level of networks security.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8239505,no,
727,The Significant Effects of Data Sampling Approaches on Software Defect Prioritization and Classification,"Context: Recent studies have shown that performance of defect prediction models can be affected when data sampling approaches are applied to imbalanced training data for building defect prediction models. However, the magnitude (degree and power) of the effect of these sampling methods on the classification and prioritization performances of defect prediction models is still unknown. Goal: To investigate the statistical and practical significance of using resampled data for constructing defect prediction models. Method: We examine the practical effects of six data sampling methods on performances of five defect prediction models. The prediction performances of the models trained on default datasets (no sampling method) are compared with that of the models trained on resampled datasets (application of sampling methods). To decide whether the performance changes are significant or not, robust statistical tests are performed and effect sizes computed. Twenty releases of ten open source projects extracted from the PROMISE repository are considered and evaluated using the AUC, pd, pf and G-mean performance measures. Results: There are statistical significant differences and practical effects on the classification performance (pd, pf and G-mean) between models trained on resampled datasets and those trained on the default datasets. However, sampling methods have no statistical and practical effects on defect prioritization performance (AUC) with small or no effect values obtained from the models trained on the resampled datasets. Conclusions: Existing sampling methods can properly set the threshold between buggy and clean samples, while they cannot improve the prediction of defect-proneness itself. Sampling methods are highly recommended for defect classification purposes when all faulty modules are to be considered for testing.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8170123,no,
728,Thermo-mechanical reliability analysis of flip-chip bonded silicon carbide Schottky diodes,"This paper presents the thermo-mechanical reliability analysis of a novel chip-scale wire bondless packaging technique for a SiC Schottky diode that leads to lower parasitics, higher reliability, lower costs, and lower losses. The proposed approach uses a flip-chip solder ball array to make connections to the anode. A copper connector was used to make contact with the bottom cathode, thus reconfiguring the bare die into a chip-scale, flip-chip capable device. Thermo-mechanical analysis in a finite element software showed that the proposed approach could better manage Coefficient of Thermal Expansion (CTE) mismatch stresses arising at the critical module interfaces as compared with a conventional wire bonded module. A detailed analysis of the flip-chip structure is presented and contrasted with a state-of-the-art wire bonded module. Different design parameters were explored for the drain connector to be able to make an optimized decision. However, keeping production costs low was prioritized without compromising significant performance. The fabrication process for manufacturing a flip-chip schottky diode module was also demonstrated along with preliminary test results to demonstrate functionality.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7936756,no,
729,TITAN: Test Suite Optimization for Highly Configurable Software,"Exhaustive testing of highly configurable software developed in continuous integration is rarely feasible in practice due to the configuration space of exponential size on the one hand, and strict time constraints on the other. This entails using selective testing techniques to determine the most failure-inducing test cases, conforming to highly-constrained time budget. These challenges have been well recognized by researchers, such that many different techniques have been proposed. In practice, however, there is a lack of efficient tools able to reduce high testing effort, without compromising software quality. In this paper we propose a test suite optimization technology TITAN, which increases the time-and cost-efficiency of testing highly configurable software developed in continuous integration. The technology implements practical test prioritization and minimization techniques, and provides test traceability and visualization for improving the quality of testing. We present the TITAN tool and discuss a set of methodological and technological challenges we have faced during TITAN development. We evaluate TITAN in testing of Cisco's highly configurable software with frequent high quality releases, and demonstrate the benefit of the approach in such a complex industry domain.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7928010,yes,
730,Towards Execution Time Prediction for Manual Test Cases from Test Specification,"Knowing the execution time of test cases is important to perform test scheduling, prioritization and progress monitoring. This work in progress paper presents a novel approach for predicting the execution time of test cases based on test specifications and available historical data on previously executed test cases. Our approach works by extracting timing information (measured and maximum execution time)for various steps in manual test cases. This information is then used to estimate the maximum time for test steps that have not previously been executed, but for which textual specifications exist. As part of our approach, natural language parsing of the specifications is performed to identify word combinations to check whether existing timing information on various test activities is already available or not. Finally, linear regression is used to predict the actual execution time for test cases. A proof-of-concept use case at Bombardier Transportation serves to evaluate the proposed approach.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8051381,no,
731,Towards the design of a secure and compliant framework for OpenEMR,"The purpose of this research is to explore and identify the vulnerabilities in OpenEMR 5.0.0, which is a free and open source medical practice management application. We are to provide recommendations/suggestions to OpenEMR developers on identifying the vulnerabilities. We chose to use vulnerabilities scanning tools to manually explore the demo site of OpenEMR 5.0.0. The targeted vulnerabilities belong to the following three types, namely, SQL Injection, Cross-Site Scripting (XSS) including persistent XSS and reflected XSS and Arbitrary File Upload. We have inducted a qualitative based risk assessment to determine the risk levels for the vulnerabilities identified. The results of risk assessment include two kinds of risk levels, which are high risk and medium risk, and two kinds of priorities, which are priority 1 (high) and priority 2 (medium). In addition, we provided recommendations and best practices about how to prevent the identified vulnerabilities. Furthermore, the research also presents an exploit automation program written in Python to test and exploit the vulnerabilities including SQL Injection and reflected XSS on the demo server of OpenEMR.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8217792,no,
732,Trends on empty exception handlers for Java open source libraries,"Exception-handling structures provide a means to recover from unexpected or undesired flows that occur during software execution, allowing the developer to put the program in a valid state. Still, the application of proper exception-handling strategies is at the bottom of priorities for a great number of developers. Studies have already discussed this subject pinpointing that, frequently, the implementation of exception-handling mechanisms is enforced by compilers. As a consequence, several anti-patterns about Exception-handling are already identified in literature. In this study, we have picked several releases from different Java programs and we investigated one of the most well-known anti-patterns: the empty catch handlers. We have analysed how the empty handlers evolved through several releases of a software product. We have observed some common approaches in terms of empty catches' evolution. For instance, often an empty catch is transformed into a empty catch with a comment. Moreover, for the majority of the programs, the percentage of empty handlers has decreased when comparing the first and last releases. Future work includes the automation of the analysis allowing the inclusion of data collected from other software artefacts: test suites and data from issue tracking systems.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7884644,no,
733,Value-Based Decision-Making Using a Web-Based Tool: A Multiple Case Study,"[Context]: To remain competitive, innovative and to grow, companies should use a value-based decision-making where decisions are the best for that company's overall value creation. However, without tool support, the use of explicit value propositions and aggregation of different key stakeholders' decisions during decision-making may be a challenge for many companies. [Goal]: The goal of this paper is to investigate the extent to which a Web-based tool for value-based decision-making can successfully support stakeholders' decision-making process. [Method]: We conducted three case studies across four software projects, during six weeks, in the contexts of feature selection, test cases execution prioritization and user interfaces design selection. Prior to using the tool, stakeholders' value propositions were elicited via focus-group meetings; later, during a post-mortem phase, data was gathered via observation, semi-structured interviews and structured questionnaires. [Results]: Participants reported an improvement of their decision-making process and quality of decisions; further, they also felt confident about using the tool, and that it can be useful to their work. [Conclusions]: Results suggested that the use of tool support by the stakeholders in the investigated company for value-based decision-making improved their decision-making process and the quality of decisions.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8305950,yes,
734,Weighting for Combinatorial Testing by Bayesian Inference,"Combinatorial testing (CT) is a widely-used technique to detect system interaction failures. To improve the test effectiveness of CT, prioritized combinatorial testing inputs priority weights of parameter-values, and generates combinatorial test suites based on the weights. This paper proposes a method to automatically determine the weights of parameter-values by Bayesian inference using previous testing results. Using two open source projects, we evaluate the fault detection effectiveness of the proposed weighting based prioritized combinatorial testing.",2017,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7899090,yes,
735,A Model-Based Test Case Management Approach for Integrated Sets of Domain-Specific Models,"Due to rapid improvements in the area of embedded processing hardware, the complexity of developed systems constantly increases. In order to ensure a high quality level of such systems, related quality assurance concepts have to evolve. The introduction of Model-Based Testing (MBT) approaches has shown promising results by automating and abstracting multiple activities of the software testing life cycle. Nevertheless, there is a strong need for approaches supporting scoped test models, i.e. subsets of test cases, reflecting specific test purposes driven by risk-oriented development strategies. Therefore, we developed an integrated and model-based approach supporting test case management, which incorporates the beneficial aspects of abstract development methodologies with predominant research for test case management in non-model-based scenarios. Based on a new model artifact, the integration model, tasks like cross-domain information mapping and the integration of domain-specific KPIs derived by analyses favor the subsequently applied constraint-based mechanism for test case management. Further, a prototypical implementation of these concepts within the Architecture And Analysis Framework (A3F) is elaborated and further evaluated based on representative application scenarios. A comparative view on related work leads to a conclusive statement regarding our future work.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8411751,no,
736,Aggregation process for implementation of application security management based on risk assessment,This article is devoted to the review and analysis of existing methods of ensuring information security based on risk models. The strengths and weaknesses of the model are investigated on the basis of reliability theory. The article discusses potential obstacle to managing application security effectively and describes five steps for managing security. Create inventory of application and their attributes and evaluating their role in business impact (Create a profile for each application and conduction analysis of date processed in the application). Software vulnerability search (Static Analysis (ƒ??white-boxƒ?); Dynamic Analysis (ƒ??black-boxƒ?); Interactive Analysis (ƒ??glass-boxƒ?); Mobile Application Analysis); Risk assessment and prioritization of vulnerabilities (Setting priorities for applications; Setting priorities for types of vulnerabilities; Setting priorities for the development team; Changing vulnerability priorities and reassessing risks). Elimination of vulnerabilities and minimization of risks (security manager sets priorities and firmed tasks for the development team.,2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8317039,no,
737,An Empirical Comparison of Fixed-Strength and Mixed-Strength for Interaction Coverage Based Prioritization,"Test case prioritization (TCP) plays an important role in identifying, characterizing, diagnosing, and correcting faults quickly. The TCP has been widely used to order test cases of different types, including model inputs (also called<italic>abstract test cases</italic>). Model inputs are constructed by modeling the program according to its input parameters, values, and constraints, and has been used in different testing methods, such as combinatorial interaction testing and software product line testing. The<italic>Interaction coverage-based TCP</italic>(ICTCP) uses interaction coverage information derived from the model input to order inputs. Previous studies have focused generally on the<italic>fixed-strength</italic>ICTCP, which adopts a fixed strength (<italic>i.e.</italic>, the level of parameter interactions) to support the ICTCP process. It is generally accepted that using more strengths for ICTCP,<italic>i.e.</italic>,<italic>mixed-strength</italic>ICTCP, may give better ordering than fixed-strength. To confirm whether mixed-strength is better than fixed-strength, in this paper, we report on an extensive empirical study using five real-world programs (written in C), each of which has six versions. The results of the empirical studies show that mixed-strength has better rates of interaction coverage overall than fixed-strength, but they have very similar rates of fault detection. Our results also show that fixed-strength should be used instead of the mixed-strength at the later stage of software testing. Finally, we offer some practical guidelines for testers when using interaction coverage information to prioritize model inputs, under different testing scenarios and resources.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8523673,yes,
738,Assessing Technical Debt in Automated Tests with CodeScene,"Test automation promises several advantages such as shorter lead times, higher code quality, and an executable documentation of the system's behavior. However, test automation won't deliver on those promises unless the quality of the automated test code itself is maintained, and to manually inspect the evolution of thousands of tests that change on a daily basis is impractical at best. This paper investigates how CodeScene - a tool for predictive analyses and visualizations - could be used to identify technical debt in automated test code. CodeScene combines repository mining, static code analysis, and machine learning to prioritize potential code improvements based on the most likely return on investment.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8411742,no,
739,Assessing Test Case Prioritization on Real Faults and Mutants,"Test Case Prioritization (TCP) is an important component of regression testing, allowing for earlier detection of faults or helping to reduce testing time and cost. While several TCP approaches exist in the research literature, a growing number of studies have evaluated them against synthetic software defects, called mutants. Hence, it is currently unclear to what extent TCP performance on mutants would be representative of the performance achieved on real faults. To answer this fundamental question, we conduct the first empirical study comparing the performance of TCP techniques applied to both real-world and mutation faults. The context of our study includes eight well-studied TCP approaches, 35k+ mutation faults, and 357 real-world faults from five Java systems in the Defects4J dataset. Our results indicate that the relative performance of the studied TCP techniques on mutants may not strongly correlate with performance on real faults, depending upon attributes of the subject programs. This suggests that, in certain contexts, the best performing technique on a set of mutants may not be the best technique in practice when applied to real faults. We also illustrate that these correlations vary for mutants generated by different operators depending on whether chosen operators reflect typical faults of a subject program. This highlights the importance, particularly for TCP, of developing mutation operators tailored for specific program domains.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530033,yes,
740,BP: Profiling Vulnerabilities on the Attack Surface,"Security practitioners use the attack surface of software systems to prioritize areas of systems to test and analyze. To date, approaches for predicting which code artifacts are vulnerable have utilized a binary classification of code as vulnerable or not vulnerable. To better understand the strengths and weaknesses of vulnerability prediction approaches, vulnerability datasets with classification and severity data are needed. The goal of this paper is to help researchers and practitioners make security effort prioritization decisions by evaluating which classifications and severities of vulnerabilities are on an attack surface approximated using crash dump stack traces. In this work, we use crash dump stack traces to approximate the attack surface of Mozilla Firefox. We then generate a dataset of 271 vulnerable files in Firefox, classified using the Common Weakness Enumeration (CWE) system. We use these files as an oracle for the evaluation of the attack surface generated using crash data. In the Firefox vulnerability dataset, 14 different classifications of vulnerabilities appeared at least once. In our study, 85.3% of vulnerable files were on the attack surface generated using crash data. We found no difference between the severity of vulnerabilities found on the attack surface generated using crash data and vulnerabilities not occurring on the attack surface. Additionally, we discuss lessons learned during the development of this vulnerability dataset.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8543394,no,
741,Characterizing Defective Configuration Scripts Used for Continuous Deployment,"In software engineering, validation and verification (V&V) resources are limited and characterization of defective software source files can help in efficiently allocating V&V resources. Similar to software source files, defects occur in the scripts used to automatically manage configurations and software deployment infrastructure, often known as infrastructure as code (IaC) scripts. Defects in IaC scripts can have dire consequences, for example, creating large-scale system outages. Identifying the characteristics of defective IaC scripts can help in mitigating these defects by allocating V&V efforts efficiently based upon these characteristics. The objective of this paper is to help software practitioners to prioritize validation and verification efforts for infrastructure as code (IaC) scripts by identifying the characteristics of defective IaC scripts. Researchers have previously extracted text features to characterize defective software source files written in general purpose programming languages. We investigate if text features can be used to identify properties that characterize defective IaC scripts. We use two text mining techniques to extract text features from IaC scripts: the bag-of-words technique, and the term frequency-inverse document frequency (TF-IDF) technique. Using the extracted features and applying grounded theory, we characterize defective IaC scripts. We also use the text features to build defect prediction models with tuned statistical learners. We mine open source repositories from Mozilla, Openstack, and Wikimedia Commons, to construct three case studies and evaluate our methodology. We identify three properties that characterize defective IaC scripts: filesystem operations, infrastructure provisioning, and managing user accounts. Using the bag-of-word technique, we observe a median F-Measure of 0.74, 0.71, and 0.73, respectively, for Mozilla, Openstack, and Wikimedia Commons. Using the TF-IDF technique, we observe a median F-Measure of 0.72, 0.74, and 0.70, respectively, for Mozilla, Openstack, and Wikimedia Commons.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8367034,no,
742,Clustering Based Prioritization of Test Cases,"Regression testing is the procedure of retesting the product and checking whether additional faults or errors have been created in the existing one. It is vital for keeping up programming quality. But it is a costly process. By., utilizing prioritization technique cost can be diminished. Prioritization increases productiveness of regression testing and its main criteria is to build the rate of error detection. Merging requirements information into current testing practice helps the engineers to recognize the source of faults easily. In this paper a research is done on whether the requirements-based grouping methodology can enhance the viability of prioritization techniques. So., here a grouping approach is performed on given requirements and prioritization techniques based on code scope metric.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8473253,yes,
743,Component Selection in Software Engineering - Which Attributes are the Most Important in the Decision Process?,"Component-based software engineering is a common approach to develop and evolve contemporary software systems where different component sourcing options are available: 1)Software developed internally (in-house), 2)Software developed outsourced, 3)Commercial of the shelf software, and 4) Open Source Software. However, there is little available research on what attributes of a component are the most important ones when selecting new components. The object of the present study is to investigate what matters the most to industry practitioners during component selection. We conducted a cross-domain anonymous survey with industry practitioners involved in component selection. First, the practitioners selected the most important attributes from a list. Next, they prioritized their selection using the Hundred-Dollar ($100) test. We analyzed the results using Compositional Data Analysis. The descriptive results showed that Cost was clearly considered the most important attribute during the component selection. Other important attributes for the practitioners were: Support of the component, Longevity prediction, and Level of off-the-shelf fit to product. Next, an exploratory analysis was conducted based on the practitioners' inherent characteristics. Nonparametric tests and biplots were used. It seems that smaller organizations and more immature products focus on different attributes than bigger organizations and mature products which focus more on Cost.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8498206,no,
744,Context-Aware Patch Generation for Better Automated Program Repair,"The effectiveness of search-based automated program repair is limited in the number of correct patches that can be successfully generated. There are two causes of such limitation. First, the search space does not contain the correct patch. Second, the search space is huge and therefore the correct patch cannot be generated (ie correct patches are either generated after incorrect plausible ones or not generated within the time budget). To increase the likelihood of including the correct patches in the search space, we propose to work at a fine granularity in terms of AST nodes. This, however, will further enlarge the search space, increasing the challenge to find the correct patches. We address the challenge by devising a strategy to prioritize the candidate patches based on their likelihood of being correct. Specifically, we study the use of AST nodes' context information to estimate the likelihood. In this paper, we propose CapGen, a context-aware patch generation technique. The novelty which allows CapGen to produce more correct patches lies in three aspects: (1) The fine-granularity design enables it to find more correct fixing ingredients; (2) The context-aware prioritization of mutation operators enables it to constrain the search space; (3) Three context-aware models enable it to rank correct patches at high positions before incorrect plausible ones. We evaluate CapGen on Defects4J and compare it with the state-of-the-art program repair techniques. Our evaluation shows that CapGen outperforms and complements existing techniques. CapGen achieves a high precision of 84.00% and can prioritize the correct patches before 98.78% of the incorrect plausible ones.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453055,no,
745,DevOps Improvements for Reduced Cycle Times with Integrated Test Optimizations for Continuous Integration,"DevOps, as a growing development practice that aims to enable faster development and efficient deployment of applications without compromising on quality, is often hampered by long cycle times. One contributing factor to long cycle times in DevOps is long build time. Automated testing in continuous integration is one of the build stages that is highly prone to long run-time due to software complexity and evolution, and inefficient due to unoptimized testing approaches. To be cost-effective, testing in continuous integration needs to use only a fast-running set of comprehensive tests that are able to ensure the level of quality needed for deployment to production. Known approaches use time-aware test selection methods to improve time-efficiency of continuous integration testing by providing optimized combinations and order of tests with respect to decreased run-time. However, focusing on time-efficiency as the sole criterion in DevOps often jeopardizes the quality of software deliveries. This paper proposes a technique that integrates fault-based and risk-based test selection and prioritization optimized for low run-time, to improve time-effectiveness of continuous integration testing, and thus reduce long cycle times in DevOps, without compromising on quality. The technique has been evaluated in testing of a large-scale configurable software in continuous integration, and has shown considerable improvement over industry practice with respect to time-efficiency.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8377636,yes,
746,Dynamic programming optimization algorithm applied in test case selection,"In this paper we propose a quadratic dynamic programming algorithm applied in software testing domain, more specific in the test case selection decision making. We addressed a specific problem in software testing: running a subset of test cases from the whole set of available test cases in a limited time frame with the goal of maximizing the chances of finding potential defects. We employed both objective methods as the dynamic programming algorithm and subjective and empiric human decision as defining the selection and prioritization criteria. The proposed solution is suited for medium to large projects where in the worst-case scenarios the memory space complexity of the proposed algorithm does not exceed the order of GBytes. The proposed optimization algorithm is presented in pseudocode along with the dynamic programming recurrence formula and potential selection criteria as currently used in the industry.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8583984,no,
747,Dynamic Random Testing Strategy for Test Case Optimization in Cloud Environment,"Dynamic Random Testing (DRT) strategy employs feedback mechanism to guide the selection of test cases, which has shown to be effective in fault detection process. Cloud testing is the combination of cloud computing and software testing, in which the parallel mechanism is introduced to handle multiple test tasks simultaneously. The efficiency of DRT can be improved by combining it into cloud environment. However, it faces challenges in cloud testing as its test cases are selected sequentially, which does not consist with the characteristic of parallelism underlying cloud testing. In this paper, we present a cloud-based DRT strategy to adapt DRT in cloud testing, in which both the test case prioritization and resource allocation are considered. The results of the experiments show that the cloud-based DRT can improve the efficiency of original DRT and provide stable fault detection performance enhancement over other testing strategies.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8539185,yes,
748,Embedded Platform for Gas Applications Using Hardware/Software Co-Design and RFID,"This paper presents the development of a wireless low power reconfigurable self-calibrated multi-sensing platform for gas sensing applications. The proposed electronic nose (EN) system monitors gas temperatures, concentrations, and mixtures wirelessly using the radio-frequency identification (RFID) technology. The EN takes the form of a set of gas and temperature sensors and multiple pattern recognition algorithms implemented on the Zynq system on chip (SoC) platform. The gas and temperature sensors are integrated on a semi-passive RFID tag to reduce the consumed power. Various gas sensors are tested, including an in-house fabricated 4??4 SnO<sub>2</sub>based sensor and seven commercial Figaro sensors. The data is transmitted to the Zynq based processing unit using a RFID reader, where it is processed using multiple pattern recognition algorithms for dimensionality reduction and classification. Multiple algorithms are explored for optimum performance, including principal component analysis (PCA) and linear discriminant analysis (LDA) for dimensionality reduction while decision tree (DT) and k-nearest neighbors (KNN) are assessed for classification purpose. Different gases are targeted at diverse concentration, including carbon monoxide (CO), ethanol (C<sub>2</sub>H<sub>6</sub>O), carbon dioxide (CO<sub>2</sub>), propane (C<sub>3</sub>H<sub>8</sub>), ammonia (NH<sub>3</sub>), and hydrogen (H<sub>2</sub>). An accuracy of 100% is achieved in many cases with an overall accuracy above 90% in most scenarios. Finally, the hardware/software heterogeneous solution to implementation PCA, LDA, DT, and KNN on the Zynq SoC shows promising results in terms of resources usage, power consumption, and processing time.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8330010,no,
749,FAST Approaches to Scalable Similarity-Based Test Case Prioritization,"Many test case prioritization criteria have been proposed for speeding up fault detection. Among them, similarity-based approaches give priority to the test cases that are the most dissimilar from those already selected. However, the proposed criteria do not scale up to handle the many thousands or even some millions test suite sizes of modern industrial systems and simple heuristics are used instead. We introduce the FAST family of test case prioritization techniques that radically changes this landscape by borrowing algorithms commonly exploited in the big data domain to find similar items. FAST techniques provide scalable similarity-based test case prioritization in both white-box and black-box fashion. The results from experimentation on real world C and Java subjects show that the fastest members of the family outperform other black-box approaches in efficiency with no significant impact on effectiveness, and also outperform white-box approaches, including greedy ones, if preparation time is not counted. A simulation study of scalability shows that one FAST technique can prioritize a million test cases in less than 20 minutes.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453081,yes,
750,"Feature-Based Testing by Using Model Synthesis, Test Generation and Parameterizable Test Prioritization","An approach for feature-based testing in efficient test processes, especially for use in agile development, is presented. Methods of model synthesis, model-based test generation, as well as coverage-based and requirement-based test prioritization are linked together in order to systematically and efficiently obtain prioritized test cases. The result is a reordered test suite promising quick feedback for the test engineer during test execution. The process is highly parameterizable in regard to the selection of features to be tested and the optimization criteria for the test prioritization. Using an example from industrial automation, the results of the work are demonstrated.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8411744,yes,
751,Functional Dependency Detection for Integration Test Cases,"This paper presents a natural language processing (NLP) based approach that, given software requirements specification, allows the functional dependency detection between integration test cases. We analyze a set of internal signals to the implemented modules for detecting dependencies between requirements and thereby identifying dependencies between test cases such that: module 2 depends on module 1 if an output internal signal from module 1 enters as an input internal signal to the module 2. Consequently, all requirements (and thereby test cases) for module 2 are dependent on all the designed requirements (and test cases) for module 1. The dependency information between requirements (and thus corresponding test cases) can be utilized for test case prioritization and scheduling. We have implemented our approach as a tool and the feasibility is evaluated through an industrial use case in the railway domain at Bombardier Transportation (BT), Sweden.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8431975,yes,
752,Graphite: A Greedy Graph-Based Technique for Regression Test Case Prioritization,"To date, various test prioritization techniques have been developed, but the majority of these techniques consider a single objective that could limit the applicability of prioritization techniques by ignoring practical constraints imposed on regression testing. Multi-objective prioritization techniques try to reorder test cases so that they can optimize multiple goals that testers want to achieve. In this paper, we introduced a novel graph-based framework that maps the prioritization task to a graph traversal algorithm. To evaluate our approach, we performed an empirical study using 20 versions of four open source applications. Our results indicate that the use of the graph-based technique can improve the effectiveness and efficiency of test case prioritization technique.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8539203,yes,
753,How Do Software Metrics Affect Test Case Prioritization?,"In this paper we consider a statistical method to prioritize software test cases with operational profile, where the system behavior is described by a Markov reward model. Especially, we introduce software code metrics as reward parameters and apply the resulting Markov reward model to the test case prioritization problem, where our research question is set as how software code metrics affect the test case prioritization. In a numerical example with a real application software, we embed some seeding faults in advance and carry out 1,000 random test experiments. It is shown that our metrics-based test case prioritization can reduce a large amount of testing effort efficiently.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8377662,yes,
754,Identifying Technical Debt in Database Normalization Using Association Rule Mining,"In previous work, we explored a new context of technical debt that relates to database normalization design decisions. We claimed that database normalization debts are likely to be incurred for tables below the fourth normal form. We proposed a method to prioritize the tables that should be normalized based on their impact on data quality and performance. In this study, we propose a framework to identify normalization debt items (i.e. tables below the fourth normal form) by mining the data stored in each table. Our framework makes use of association rule mining to discover functional dependencies between attributes in a table, which will help determine the current normal form of that table and reveal debt tables. To illustrate our method, we use a case study from Microsoft, AdventureWorks database. The results revealed the applicability of our framework to identify debt tables.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8498244,no,
755,Industrially Applicable System Regression Test Prioritization in Production Automation,"When changes are performed on an automated production system (aPS), new faults can be accidentally introduced into the system, which are called regressions. A common method for finding these faults is regression testing. In most cases, this regression testing process is performed under high time pressure and onsite in a very uncomfortable environment. Until now, there has been no automated support for finding and prioritizing system test cases regarding the fully integrated aPS that are suitable for finding regressions. Thus, the testing technician has to rely on personal intuition and experience, possibly choosing an inappropriate order of test cases, finding regressions at a very late stage of the test run. Using a suitable prioritization, this iterative process of finding and fixing regressions can be streamlined and a lot of time can be saved by executing test cases likely to identify new regressions earlier. Thus, an approach is presented in this paper that uses previously acquired runtime data from past test executions and performs a change identification and impact analysis to prioritize test cases that have a high probability to unveil regressions caused by side effects of a system change. The approach was developed in cooperation with reputable industrial partners active in the field of aPS engineering, ensuring a development in line with industrial requirements. An industrial case study and an expert evaluation were performed, showing promising results.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8320514,no,
756,Influencers of Quality Assurance in an Open Source Community,"ROS (Robot Operating System) is an open source community in robotics that is developing standard robotics operating system facilities such as hardware abstraction, low-level device control, communication middleware, and a wide range of software components for robotics functionality. This paper studies the quality assurance practices of the ROS community. We use qualitative methods to understand how ideology, priorities of the community, culture, sustainability, complexity, and adaptability of the community affect the implementation of quality assurance practices. Our analysis suggests that software engineering practices require social and cultural alignment and adaptation to the community particularities to achieve seamless implementation in open source environments. This alignment should be incorporated into the design and implementation of quality assurance practices in open source communities.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8445538,no,
757,Integrating Weight Assignment Strategies With NSGA-II for Supporting User Preference Multiobjective Optimization,"Driven by the needs of several industrial projects on the applications of multiobjective search algorithms, we observed that user preferences must be properly incorporated into optimization objectives. However, existing algorithms usually treat all the objectives with equal priorities and do not provide a mechanism to reflect user preferences. To address this, we propose an extension-user-preference multiobjective optimization algorithm (UPMOA), to the most commonly applied, nondominated sorting genetic algorithm II by introducing a user preference indicator ??, based on existing weight assignment strategies [e.g., uniformly distributed weights (UDW)]. We empirically evaluated UPMOA using four industrial problems from three diverse domains (i.e., communication, maritime, and subsea oil and gas). We also performed a sensitivity analysis for UPMOA with 625 algorithm parameter settings. To further assess the performance and scalability, 103 500 artificial problems were created and evaluated representing 207 sets of user preferences. Results show that the UDW strategy with UPMOA achieves the best performance and UPMOA significantly outperformed other three multiobjective search algorithms, and has the ability to solve problems with a wide range of complexity. We also observed that different parameter settings led to the varied performance of UPMOA, thus suggesting that configuring proper parameters is highly problem-specific.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8123878,no,
758,Investigating NLP-Based Approaches for Predicting Manual Test Case Failure,"System-level manual acceptance testing is one of the most expensive testing activities. In manual testing, typically, a human tester is given an instruction to follow on the software. The results as ""passed"" or ""failed"" will be recorded by the tester, according to the instructions. Since this is a labourintensive task, any attempt in reducing the amount of this type of expensive testing is essential, in practice. Unfortunately, most of the existing heuristics for reducing test executions (e.g., test selection, prioritization, and reduction) are either based on source code or specification of the software under test, which are typically not being accessed during manual acceptance testing. In this paper, we propose a test case failure prediction approach for manual testing that can be used as a noncode/ specifcation-based heuristic for test selection, prioritization, and reduction. The approach uses basic Information Retrieval (IR) methods on the test case descriptions, written in natural language. The IR-based measure is based on the frequency of terms in the manual test scripts. We show that a simple linear regression model using the extracted natural language/IR-based feature together with a typical history-based feature (previous test execution results) can accurately predict the test cases' failure in new releases. We have conducted an extensive empirical study on manual test suites of 41 releases of Mozilla Firefox over three projects (Mobile, Tablet, Desktop). Our comparison of several proposed approaches for predicting failure shows that a) we can accurately predict the test case failure and b) the NLP-based feature can improve the prediction models.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8367058,no,
759,Learning to Accelerate Compiler Testing,"Compilers are one of the most important software infrastructures. Compiler testing is an effective and widely-used way to assure the quality of compilers. While many compiler testing techniques have been proposed to detect compiler bugs, these techniques still suffer from the serious efficiency problem. This is because these techniques need to run a large number of randomly generated test programs on the fly through automated test-generation tools (e.g., Csmith). To accelerate compiler testing, it is desirable to schedule the execution order of the generated test programs so that the test programs that are more likely to trigger compiler bugs are executed earlier. Since different test programs tend to trigger the same compiler bug, the ideal goal of accelerating compiler testing is to execute the test programs triggering different compiler bugs in the beginning. However, such perfect goal is hard to achieve, and thus in this work, we design four steps to approach the ideal goal through learning, in order to largely accelerate compiler testing.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449630,no,
760,MDroid+: A Mutation Testing Framework for Android,"Mutation testing has shown great promise in assessing the effectiveness of test suites while exhibiting additional applications to test-case generation, selection, and prioritization. Traditional mutation testing typically utilizes a set of simple language specific source code transformations, called operators, to introduce faults. However, empirical studies have shown that for mutation testing to be most effective, these simple operators must be augmented with operators specific to the domain of the software under test. One challenging software domain for the application of mutation testing is that of mobile apps. While mobile devices and accompanying apps have become a mainstay of modern computing, the frameworks and patterns utilized in their development make testing and verification particularly difficult. As a step toward helping to measure and ensure the effectiveness of mobile testing practices, we introduce MDroid+, an automated framework for mutation testing of Android apps. MDroid+ includes 38 mutation operators from ten empirically derived types of Android faults and has been applied to generate over 8,000 mutants for more than 50 apps.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449438,no,
761,Methods and Tools for Focusing and Prioritizing the Testing Effort,"Software testing is essential for any software development process, representing an extremely expensive activity. Despite its importance recent studies showed that developers rarely test their application and most programming sessions end without any test execution. Indeed, new methods and tools able to better allocating the developers effort are needed to increment the system reliability and to reduce the testing costs. In this work we focus on three activities able to optimize testing activities, specifically, bug prediction, test case prioritization, and energy leaks detection. Indeed, despite the effort devoted in the last decades by the research community led to interesting results, we highlight some aspects that might be improved and propose empirical investigations and novel approaches. Finally, we provide a set of open issues that should be addressed by the research community in the future.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530092,yes,
762,MS-guided many-objective evolutionary optimisation for test suite minimisation,"Test suite minimisation is a process that seeks to identify and then eliminate the obsolete or redundant test cases from the test suite. It is a trade-off between cost and other value criteria and is appropriate to be described as a many-objective optimisation problem. This study introduces a mutation score (MS)-guided many-objective optimisation approach, which prioritises the fault detection ability of test cases and takes MS, cost and three standard code coverage criteria as objectives for the test suite minimisation process. They use six classical evolutionary many-objective optimisation algorithms to identify efficient test suite, and select three small programs from the Software-Artefact Infrastructure Repository (SIR) and two larger program space and gzip for experimental evaluation as well as statistical analysis. The experiment results of the three small programs show non-dominated sorting genetic algorithm II (NSGA-II) with tuning was the most effective approach. However, MOEA/D-PBI and MOEA/D-WS outperform NSGA-II in the cases of two large programs. On the other hand, the test cost of the optimal test suite obtained by their proposed MS-guided many-objective optimisation approach is much lower than the one without it in most situation for both small programs and large programs.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8572623,yes,
763,On the Selection of Strength for Fixed-Strength Interaction Coverage Based Prioritization,"Abstract test cases are derived by modeling the system under test, and have been widely applied in practice, such as for software product line testing and combinatorial testing. Abstract test case prioritization (ATCP) is used to prioritize abstract test cases and aims at achieving higher rates of fault detection. Many ATCP algorithms have been proposed, using different prioritization criteria and information. One ATCP approach makes use of fixed-strength level-combinations information covered by abstract test cases, and is called fixed-strength interaction coverage based prioritization (FICBP). Before using FICBP, the prioritization strength ?¯ needs to be decided. Previous studies have generally focused on ?¯ values ranging between 1 and 6. However, no study has investigated the appropriateness of such a range, nor how to assign the prioritization strength for FICBP. To answer these questions, this paper reports on an empirical study involving four real-life programs (each of which with six versions). The experimental results indicate that ?¯ should be set approximately equal to a value corresponding to half of the number of parameters, when testing resources are sufficient. Our results also show that when testing resources are limited or insufficient, either small or large ?¯ values are suggested for FICBP.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8377673,yes,
764,On the Suitability of a Portfolio-Based Design Improvement Approach,"The design debt metaphor tries to illustrate quality deficits in the design of a software and the impact thereof to the business value of the system. To pay off the debt, the literature offers various approaches for identifying and prioritizing these design flaws, but without proper support in aligning strategic improvement actions to the identified issues. This work addresses this challenge and examines the suitability of our proposed portfolio-based design assessment approach. Therefore, this investigation is conducted based on three case studies where the product source code was analyzed and assessed using our portfolio-based approach. As a result, the approach has proven to be able to recommend concrete and valuable design improvement actions that can be adapted to project constraints.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8424976,no,
765,Poster: An Experimental Analysis of Fault Detection Capabilities of Covering Array Constructors,"Combinatorial Interaction Testing (CIT) aims at constructing an effective test suite, such as a Covering Array (CA), that can detect faults that are caused by the interaction of parameters. In this paper, we report on some empirical studies conducted to examine the fault detection capabilities of five popular CA constructors: ACTS, Jenny, PICT, CASA, and TCA. The experimental results indicate that Jenny has the best performance, because it achieves better fault detection than the other four constructors in many cases. Our results also indicate that CAs generated using ACTS, PICT, or CASA should be prioritized before testing.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449522,no,
766,Poster: Identification of Methods with Low Fault Risk,"Test resources are usually limited and therefore it is often not possible to completely test an application before a release. Therefore, testers need to focus their activities on the relevant code regions. In this paper, we introduce an inverse defect prediction approach to identify methods that contain hardly any faults. We applied our approach to six Java open-source projects and show that on average 31.6% of the methods of a project have a low fault risk; they contain in total, on average, only 5.8% of all faults. Furthermore, the results suggest that, unlike defect prediction, our approach can also be applied in cross-project prediction scenarios. Therefore, inverse defect prediction can help prioritize untested code areas and guide testers to increase the fault detection probability.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449591,yes,
767,Practical Test Dependency Detection,"Regression tests should consistently produce the same outcome when executed against the same version of the system under test. Recent studies, however, show a different picture: in many cases simply changing the order in which tests execute is enough to produce different test outcomes. These studies also identify the presence of dependencies between tests as one likely cause of this behavior. Test dependencies affect the quality of tests and of the correlated development activities, like regression test selection, prioritization, and parallelization, which assume that tests are independent. Therefore, developers must promptly identify and resolve problematic test dependencies. This paper presents PRADET, a novel approach for detecting problematic dependencies that is both effective and efficient. PRADET uses a systematic, data-driven process to detect problematic test dependencies significantly faster and more precisely than prior work. PRADET scales to analyze large projects with thousands of tests that existing tools cannot analyze in reasonable amount of time, and found 27 previously unknown dependencies.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8367031,yes,
768,Prioritization of Metamorphic Relations Based on Test Case Execution Properties,"A test oracle is essential for software testing. In certain complex systems, it is hard to distinguish between correct and incorrect behavior. Metamorphic testing is one of the solution to solve the test oracle problem. In metamorphic testing, metamorphic relations (MRs) are derived based on the properties exhibited by the program under test (PUT). These MRs play a major role in the generation of test data for conducting MT. The effectiveness of MRs can be determined based on the ability to detect considerable faults for the given PUT. Many metamorphic relations with different fault finding capability can be used to test the PUT and it is important to identify and prioritize the MRs based on its fault finding effectiveness. In order to answer this challenge, we propose to prioritize the MRs based on the diversity in the execution path of the source and follow-up test cases of the MRs. We propose four metrics to capture different levels of diversity in the execution behavior of the test cases for each of the derived MRs. The total weight calculated for each of the MRs using the metrics is used to prioritize the MRs.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8539189,no,
769,"Prioritizing Alerts from Multiple Static Analysis Tools, Using Classification Models","Static analysis (SA) tools examine code for flaws without executing the code, and produce warnings (""alerts"") about possible flaws. A human auditor then evaluates the validity of the purported code flaws. The effort required to manually audit all alerts and repair all confirmed code flaws is often too much for a project's budget and schedule. An alert triaging tool enables strategically prioritizing alerts for examination, and could use classifier confidence. We developed and tested classification models that predict if static analysis alerts are true or false positives, using a novel combination of multiple static analysis tools, features from the alerts, alert fusion, code base metrics, and archived audit determinations. We developed classifiers using a partition of the data, then evaluated the performance of the classifier using standard measurements, including specificity, sensitivity, and accuracy. Test results and overall data analysis show accurate classifiers were developed, and specifically using multiple SA tools increased classifier accuracy, but labeled data for many types of flaws were inadequately represented (if at all) in the archive data, resulting in poor predictive accuracy for many of those flaws.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8445036,no,
770,Prioritizing Browser Environments for Web Application Test Execution,"When testing client-side web applications, it is important to consider different web-browser environments. Different properties of these environments such as web-browser types and underlying platforms may cause a web application to exhibit different types of failures. As web applications evolve, they must be regression tested across these different environments. Because there are many environments to consider this process can be expensive, resulting in delayed feedback about failures in applications. In this work, we propose six techniques for providing a developer with faster feedback on failures when regression testing web applications across different web-browser environments. Our techniques draw on methods used in test case prioritization; however, in our case we prioritize web-browser environments, based on information on recent and frequent failures. We evaluated our approach using four non-trivial and popular open-source web applications. Our results show that our techniques outperform two baseline methods, namely, no ordering and random ordering, in terms of the cost-effectiveness. The improvement rates ranged from -12.24% to 39.05% for no ordering, and from -0.04% to 45.85% for random ordering.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453107,yes,
771,Redefining Prioritization: Continuous Prioritization for Continuous Integration,"Continuous integration (CI) development environments allow soft-ware engineers to frequently integrate and test their code. While CI environments provide advantages, they also utilize non-trivial amounts of time and resources. To address this issue, researchers have adapted techniques for test case prioritization (TCP) to CI environments. To date, however, the techniques considered have operated on test suites, and have not achieved substantial improvements. Moreover, they can be inappropriate to apply when system build costs are high. In this work we explore an alternative: prioritization of commits. We use a lightweight approach based on test suite failure and execution history that is highly efficient; our approach ""continuously"" prioritizes commits that are waiting for execution in response to the arrival of each new commit and the completion of each previously scheduled commit. We have evaluated our approach on three non-trivial CI data sets. Our results show that our approach can be more effective than prior techniques.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453137,yes,
772,Region Priority Based Adaptive 360-Degree Video Streaming Using DASH,"With the continuous improvement of Virtual Reality (VR) hardware and software facilities and development of VR streaming platform, the VR industry ushered in a period of rapid development. VR makes use of 360-degree panoramic or omnidirectional video with high resolution and high frame rate in order to create the immersive experience to the user. However those characteristics cause the big volume of 360-degree video and bandwidth intensive during transmission. Due to the limitation of the human eye vision, the user can only watch the part of the 360-degree video in a head-mounted display (HMD) at one time. Hence, streaming the VR video by the traditional video transmission method causes bandwidth waste. In view of this, this paper proposed a 360-degree video adaptive transmission method based on user viewport. Firstly, a 360-degree video region prioritization scheme is proposed based on user vision characteristics and head motion features. Different priority regions transmit 360-degree video content with different quality levels as the format of tiles. Then, based on the bandwidth estimation, buffer status and user viewport prediction, a 360-degree video adaptive transmission decision strategy is given. According to the predicted available bandwidth and viewport, the quality combination of the 360-degree video tiles to be transmitted in the near future is determined to implement adaptive transmission. The test results of the 360-degree video transmission experiment system based on the DASH standard show that the proposed 360-degree video adaptive transmission strategy can effectively reduce the bandwidth consumption on the basis of guaranteeing the user Quality of Experience(QoE).",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8455396,no,
773,REMAP: Using Rule Mining and Multi-objective Search for Dynamic Test Case Prioritization,"Test case prioritization (TP) prioritizes test cases into an optimal order for achieving specific criteria (e.g., higher fault detection capability) as early as possible. However, the existing TP techniques usually only produce a static test case order before the execution without taking runtime test case execution results into account. In this paper, we propose an approach for black-box dynamic TP using rule mining and multi-objective search (named as REMAP). REMAP has three key components: 1) Rule Miner, which mines execution relations among test cases from historical execution data; 2) Static Prioritizer, which defines two objectives (i.e., fault detection capability (FDC) and test case reliance score (TRS)) and applies multi-objective search to prioritize test cases statically; and 3) Dynamic Executor and Prioritizer, which executes statically-prioritized test cases and dynamically updates the test case order based on the runtime test case execution results. We empirically evaluated REMAP with random search, greedy based on FDC, greedy based on FDC and TRS, static search-based prioritization, and rule-based prioritization using two industrial and three open source case studies. Results showed that REMAP significantly outperformed the other approaches for 96% of the case studies and managed to achieve on average 18% higher Average Percentage of Faults Detected (APFD).",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8367035,yes,
774,Requirements Analysis Skills: How to Train Practitioners?,"One of the goals of any software development organization (SDO) is the assurance of a high quality software. To achieve this, it is important to perform all the software related activities, especially those of the requirements engineering (RE) phase, in the right way and ideally by experts. However, the current practice reveals that this crucial phase is commonly performed by people with limited experience in RE, indeed, some of them ignoring the basic activities. We present a training plan in order to improve practitioners' RE analysis skills. The training plan was applied to 44 practitioners working at a Mexican SDO. We developed such a plan based on the idea of considering six main dimensions that include theory, tests and mentoring sessions. The so called dimensions are: understanding the organization's domain, basic concepts of RE, requirements elicitation, requirements expression, requirements prioritization and requirements analysis. In this paper, we present what are the topics discussed in each dimension, the feedback received by the practitioners after the training and how we envision the evolution of the training plan.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8501281,no,
775,SDN-Based Architecture for Providing QoS to High Performance Distributed Applications,"The specification of quality of service (QoS) requirements in traditional networks is limited by the high administrative cost of these environments. Nevertheless, newer network paradigms, as software-defined networks (SDNs), simplify and relaxes the management of networks. In this sense, SDN can provide a simple/effective way to develop QoS provisioning. In this paper, we propose a QoS provision architecture exploiting the capabilities of SDN. Our approach allows the specification of classes of service and also negotiates the QoS requirements between applications and the SDN network controller. The SDN controller, in turn, monitors the network and adjusts its performance through resource reservation and traffic prioritization. We developed a proof-of-concept of our proposal and, our experimental results show that the additional routines present low overhead, whereas -for a given test application- we observe a reduction of up to 47% in transfer times.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8538694,no,
776,Search-Based Optimization for the Testing Resource Allocation Problem: Research Trends and Opportunities,"This paper explores the usage of search-based techniques for the Testing Resource Allocation Problem (TRAP). We focus on the analysis of the literature, surveying the research proposals where search-based techniques are exploited for different formulations of the TRAP. Three dimensions are considered: the model formulation, solution, and validation. The analysis allows to derive several observations, and finally outline some new research directions towards better (namely, closer to real-world settings) modelling and solutions, highlighting the most promising areas of investigation.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8452803,no,
777,Test Case Prioritization Based on Method Call Sequences,"Test case prioritization is widely used in testing with the purpose of detecting faults as early as possible. Most existing techniques exploit coverage to prioritize test cases based on the hypothesis that a test case with higher coverage is more likely to catch bugs. Statement coverage and function coverage are the two widely used coverage granularity. The former typically achieves better test case prioritization in terms of fault detection capability, while the latter is more efficient because it incurs less overhead. In this paper we argue that static information such as statement and function coverage may not be the best criteria for guiding dynamic executions. Executions that cover the same set of statements /functions can may exhibit very different behavior. Therefore, the abstraction that reduces program behavior to statement/function coverage can be too simplistic to predicate fault detection capability. We propose a new approach that exploits function call sequences to prioritize test cases. This is based on the observation that the function call sequences rather than the set of executed functions is a better indicator of program behavior. Test cases that reveal unique function call sequences may have better chance to encounter faults. We choose function instead of statement sequences due to the consideration of efficiency. We have developed and implemented a new prioritization strategy AGC (Additional Greedy method Call sequence), that exploit function call sequences. We compare AGC against existing test case prioritization techniques on eight real-world open source Java projects. Our experiments show that our approach outperforms existing techniques on large programs (but not on small programs) in terms of bug detection capability. The performance shows a growth trend when the size of program increases.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8377663,yes,
778,Test Case Prioritization for GUI Regression Testing Based on Centrality Measures,"Regression testing has been widely used in GUI software testing. For the reason of economy, the prioritization of test cases is particularly important. However, few studies discussed test case prioritization (TCP) for GUI software. Based on GUI software features, a two-layer model is proposed to assist the test case prioritization in this paper, in which, the outer layer is an event handler tree (EHT), and the inner layer is a function call graph (FCG). Compared with the conventional methods, more source code information is used based on the two-layer model for prioritization. What is more, from a global perspective, centrality measure, a complex network viewpoint is used to highlight the importance of modified functions for specific version TCP. The experiment proved the effectiveness of this model and this method.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8377903,yes,
779,Test Re-Prioritization in Continuous Testing Environments,"New changes are constantly and concurrently being made to large software systems. In modern continuous integration and deployment environments, each change requires a set of tests to be run. This volume of tests leads to multiple test requests being made simultaneously, which warrant prioritization of such requests. Previous work on test prioritization schedules queued tests at set time intervals. However, after a test has been scheduled it will never be reprioritized even if new higher risk tests arrive. Furthermore, as each test finishes, new information is available which could be used to reprioritize tests. In this work, we use the conditional failure probability among tests to reprioritize tests after each test run. This means that tests can be reprioritized hundreds of times as they wait to be run. Our approach is scalable because we do not depend on static analysis or coverage measures and simply prioritize tests based on their co-failure probability distributions. We named this approach CODYNAQ and in particular, we propose three prioritization variants called CODYNAQSINGLE, CODYNAQDOUBLE and CODYNAQFLEXI. We evaluate our approach on two data sets, CHROME and Google testing data. We find that our co-failure dynamic re-prioritization approach, CODYNAQ, outperforms the default order, FIFOBASELINE, finding the first failure and all failures for a change request by 31% and 62% faster, respectively. CODYNAQ also outperforms GOOGLETCP by finding the first failure 27% faster and all failures 62% faster.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530018,yes,
780,Using Controlled Numbers of Real Faults and Mutants to Empirically Evaluate Coverage-Based Test Case Prioritization,"Used to establish confidence in the correctness of evolving software, regression testing is an important, yet costly, task. Test case prioritization enables the rapid detection of faults during regression testing by reordering the test suite so that effective tests are run as early as is possible. However, a distinct lack of information about the regression faults found in complex real-world software forced prior experimental studies of these methods to use artificial faults called mutants. Using the Defects4J database of real faults, this paper presents the results of experiments evaluating the effectiveness of four representative test prioritization techniques. Since this paper's results show that prioritization is susceptible to high amounts of variance when only one fault is present, our experiments also control the number of real faults and mutants in the program subject to regression testing. Our overall findings are that, in comparison to mutants, real faults are harder for reordered test suites to quickly detect, suggesting that mutants are not a surrogate for real faults.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8536351,yes,
781,Using Mutant Stubbornness to Create Minimal and Prioritized Test Sets,"In testing, engineers want to run the most useful tests early (prioritization). When tests are run hundreds or thousands of times, minimizing a test set can result in significant savings (minimization). This paper proposes a new analysis technique to address both the minimal test set and the test case prioritization problems. This paper precisely defines the concept of mutant stubbornness, which is the basis for our analysis technique. We empirically compare our technique with other test case minimization and prioritization techniques in terms of the size of the minimized test sets and how quickly mutants are killed. We used seven C language subjects from the Siemens Repository, specifically the test sets and the killing matrices from a previous study. We used 30 different orders for each set and ran every technique 100 times over each set. Results show that our analysis technique performed significantly better than prior techniques for creating minimal test sets and was able to establish new bounds for all cases. Also, our analysis technique killed mutants as fast or faster than prior techniques. These results indicate that our mutant stubbornness technique constructs test sets that are both minimal in size, and prioritized effectively, as well or better than other techniques.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8424996,yes,
782,Varying defect prediction approaches during project evolution: A preliminary investigation,"Defect prediction approaches use various features of software product or process to prioritize testing, analysis and general quality assurance activities. Such approaches require the availability of project's historical data, making them inapplicable in early phase. To cope with this problem, researchers have proposed cross-project and even cross-company prediction models, which use training material from other projects to build the model. Despite such advances, there is limited knowledge of how, as the project evolves, it would be convenient to still keep using data from other projects, and when, instead, it might become convenient to switch towards a local prediction model. This paper empirically investigates, using historical data from four open source projects, on how the performance of various kinds of defect prediction approaches - within-project prediction, local and global cross-project prediction, and mixed (injected local cross) prediction - varies over time. Results of the study are part of a long-term investigation towards supporting the customization of defect prediction models over projects' history.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8368451,yes,
783,Virtual Test Method for Complex and Variant-Rich Automotive Systems,"The fast development of embedded automotive systems in form of connected Electronic Control Units (ECUs) has led to complex development processes. Especially for safetycritical functions, the testing activities are essential to check if the designed system complies with the requirements. Nowadays, the continuous development of mobile electronic devices through software updates is performed almost on a daily basis. This trend is now starting to be observed in cyber-physical systems with higher safety priorities. In the automotive field, the rising software portion in the vehicles and the shortening technology life-cycles are accentuating the need for Software Over The Air (SOTA) updates. Despite the opportunities offered by SOTA updates, the current test processes and methods must be adapted to manage the resulting complexity throughout the life-cycle of the vehicles. Especially the typical variants abundance in automotive product lines is considered as an important challenge, which cannot be solved only by ƒ?classicalƒ? testing methods such as Hardware-In-the-Loop. In this paper, we present a testing method for variantrich systems, which can be applied for automotive software updates. It uses virtual platforms for automated delta testing to handle the abundance of system configurations. Virtual testing is introduced as a powerful tool to reduce the amount of real tests and allow efficient variants verification. As a proof of concept, an Adaptive Cruise Control (ACC) composed of two ECUs has been implemented both in real hardware and using a virtual platform. With this approach, virtual delta tests, i. e. specific test-benches targeting the differences to a basic variant, can be rapidly executed for various system configurations. To prove the feasibility of the presented test method in more complex systems, a scalability study has been conducted.",2018,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8519599,no,